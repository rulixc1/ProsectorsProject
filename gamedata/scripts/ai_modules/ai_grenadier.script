--[[ ----------------------------------------------------------------------------------------------
 File       : ai_grenadier.script
 Description: ћетание гранат
 Copyright  : 2017 © Prosectors Project
 Author(s)  : Rulix aka Bak, xStream
 Original   : AI Additions, 10.10.2016
--]] ----------------------------------------------------------------------------------------------
_DEBUG_ = false

local ui_grenade_marks = true

-- radius	- оверрайд
-- kamikazze - доступна дл€ психов-камикадзе
-- cond - throw condition function(npc,target)
-- aff - affector function(grenade_obj,data)
local grenade_params = {
	grenade_f1 = {kamikazze = true},
	grenade_rgd5 = {kamikazze = true},
	["grenade_gd-05"] = {radius = 6, cond = function(npc,trg) return npc.health > 0.8 and IsStalker(trg) end},
--	grenade_light = {radius = 10, cond = function() local h = level.get_time_hours() return h <= 5 or h >= 23 end},
}

for section,params in pairs(grenade_params) do
	local ini = system_ini()
	if not params.radius then
		local br = ini:r_float(section,"blast_r")
		local fr = ini:r_float(section,"frags_r")
		local fc = ini:r_s32(section,"frags")
		params.radius = math.max(br,math.min(fc^0.7,fr))	-- если осколков мало, то бо€тьс€ их особо не стоит
	end
	params.explode_time = ini:r_s32(section,"destroy_time")
	params.snd_checkout = m_sound.dihud_sound(section,"snd_checkout")
end

local grenades = {}
local get_grenade = level.object_by_id

local gr_ini = ini_file([[misc\ai_additions\grenadier.ltx]])
assert(gr_ini:section_exist('default'),"no gr_ini")
local forbidden_factions = parse_list(gr_ini,"main","forbidden_factions",true)
local forbidden_npcs = collect_sections(gr_ini,{"forbidden_npcs"},nil,true)
local attack_classes = collect_sections(gr_ini,{"attack_classes"},nil,true)

local check_prd = read_from_ini(gr_ini,"main","check_period",2000)
local grenade_min_dist = read_from_ini(gr_ini,"main","min_dist",10)
local grenade_max_dist = read_from_ini(gr_ini,"main","max_dist",60)
local dispersion_base = 11
local min_throw_interval = 5000	-- интервал между бросками
local min_enemy_memory_time = 2800	-- через сколько можно начинать шугать гранатой скрывшегос€ врага
local mid_enemy_memory_time = 11000	-- пора проверить, есть ли там еще враг
local max_enemy_memory_time = 36000	-- а тут пора уже заканчивать

-- настройки спавна гранат
local spawn_period = read_from_ini(gr_ini,"main","spawn_period",50)*1000
local spawn_period_gd_factor = 0.15	-- в минус
local spawn_chance_base = 0.5
local spawn_chance_rank_factor = 0.5	-- в плюс
local max_grenade_num = read_from_ini(gr_ini,"main","max_grenade_num",2,3)

-- настройки mon_psyh
local psyh_comms = parse_list(gr_ini,"psyh","factions",true)
local psyh_chance = read_from_ini(gr_ini,"psyh","chance",0.1)
local psyh_actor_only = read_from_ini(gr_ini,"psyh","actor_only",true,0)
local psyh_init_dist = 30*30
local psyh_grenade_dist = 11

local attack_clsids = {}
for cls_id,name in pairs(creatures_clslist) do
	attack_clsids[cls_id] = attack_classes[name]
end
attack_classes = nil

local profiles = {}
local function read_profile(section)
	if not gr_ini:section_exist(section) or gr_ini:line_count(section) == 0 then
		return profiles.default
	end
	if not profiles[section] then
		profiles[section] = {
		throw = gr_ini:r_bool(section,"throw"),
		evasion = gr_ini:r_bool(section,"evasion"),
		spawn_grenades = gr_ini:r_string(section,"spawn_grenades") or "",
		}
		local tmp,t,rnd = str_explode(",",profiles[section].spawn_grenades),{},0
		for _,v in ipairs(tmp) do
			local p = string.find(v,":",1,true)
			assert(p,"xrs_grenade: incorrect value spawn_grenades in %s",section)
			local gr = string.sub(v,1,p-1)
			assert(grenade_params[gr],"xrs_grenade: not registered grenade %s in %s",gr,section)
			t[gr] = tonumber(string.sub(v,p+1,-1))/100
			rnd = rnd + t[gr]
		end
		assert(rnd <= 100,"xrs_grenade: spawn chance sum > 100 in %s",section)
		profiles[section].spawn_grenades = t
	end
	return profiles[section]
end
read_profile('default')

local function delete_obj(id)
	local o = id and sim:object(id)
	if o then
		sim:release(o)
	end
--	table.insert(ids_to_remove,id)
end

----------------------------------------------------------------------------------------------------------------------
-- EVALUATORS
----------------------------------------------------------------------------------------------------------------------

class "evaluator_crazy_grenadier" (property_evaluator)
function evaluator_crazy_grenadier:__init(npc,storage,planner,name) super (nil,name)
	self.a = storage
	self.a.next_check_time = time_global()+math.random(4000,12000)
	self.a.throwing = false
	self.a.rank = m_ranks.stalker_rank_unit*npc:character_rank()
	self.disp = 2+math.max(1-self.a.rank,0)*dispersion_base
	self.planner = planner
	self.max_dist = grenade_max_dist*0.5+grenade_max_dist*0.5*math.min(self.a.rank,1)
	self.spawn_update_time = self.a.next_check_time+spawn_period*0.5
	ai_common.subscribe_for_events(npc:id(),self)
end
function evaluator_crazy_grenadier:evaluate()
	local npc = self.object

	if self.a.throwing then
		local be = npc:best_enemy()
		local enemy_wounded = be and ai_wounded.is_wounded(be) and (not ai_kill_wounded or self.storage:property(stalker_ids.property_enemy_wounded))
		if self.a.psyh_action or not be or enemy_wounded or npc:critically_wounded() or self.action_time < time_global() and self.planner:current_action_id() ~= actions_id.grenadier then
			self.a.next_check_time = time_global() + check_prd*2
			self.a.throwing = false
			return false
		end
		return true
	end

	if not self.a.throw_enabled then
		return false
	end

	if self.testing then
		local testres,pos = self:update_test()
		if testres ~= nil then
			self.a.result_pos = pos
			self.a.throwing = testres
			self.action_time = testres and time_global()+3000 or nil	-- на переход к действию только 3 секунды, не успел - начинай сначала
			if grenades[self.test_grenade] then
				grenades[self.test_grenade].time = -1
			end
			self.test_grenade = nil
			self.testing = false
			self.a.next_check_time = time_global() + check_prd
			self.wait_for_online = nil
		end
		return false
	end

	local tg = time_global()
	if self.a.next_check_time > tg then
		return false
	end
	self.a.next_check_time = tg + check_prd

	local be = npc:best_enemy()
	if not be then
		spawn_grenade(self)
		self.a.next_check_time = tg + math.random(10000,50000)	-- случайна€ задержка от начала бо€
		return false
	end

	if npc:critically_wounded() or ai_wounded.is_wounded(npc) or self.a.psyh_action then
		return false
	end

	if not attack_clsids[be:clsid()] or ai_wounded.is_wounded(be) then
		self.a.next_check_time = tg + check_prd*2
		return false
	end

	-- определим цель
	local see,memory_time,target_pos = npc:see(be)
	if IsStalker(be) then
		-- одна €чейка пам€ти
		if see then
			self.memory_id = be:id()
			self.memory_time = tg
			self.memory_pos = be:position()
			return false
		elseif self.memory_id == be:id() and tg-self.memory_time < min_enemy_memory_time then
			return false
		end
		memory_time = tg-npc:memory_time(be)
		if memory_time < 0 then
			-- подключить индивидуальную пам€ть
			if self.memory_id == be:id() then
				target_pos = self.memory_pos
				memory_time = tg-self.memory_time
			else
				memory_time = max_enemy_memory_time
--				return false
			end
		end
		if memory_time >= max_enemy_memory_time then
			return false
		end
		if npc:movement_type() == move.run and npc:mental_state() ~= anim.panic then
			return false
		end
	elseif not see then
		return false
	end
	local target_pos = target_pos or see and be:position() or npc:memory_position(be)
	-- выберем из имеющихс€ гранат нужную
	local avail_grenades = {}
	for sect,t in pairs(grenade_params) do
		local gr = npc:object(sect)
		if gr and (t.cond == nil or t.cond(npc,be)) then
			table.insert(avail_grenades,sect)
		end
	end
	if #avail_grenades < 1 then
		spawn_grenade(self)
		return false
	end
--	table.sort(avail_grenades,function(a,b) return grenade_params[a].radius > grenade_params[b].radius end)
	local choosen = avail_grenades[math.random(#avail_grenades)]
	-- проверим рассто€ние
	local npc_pos = npc:position()
	local dist = npc_pos:distance_to(target_pos)
	if dist > self.max_dist or dist < grenade_min_dist then
		self.a.next_check_time = tg + check_prd*2
		return false
	end
	-- выберем точку
	local dev = self.disp*(dist+90)
	target_pos:add(vector():set(math.random(-dev,dev)*0.01,math.random(-dev,dev)*0.004,math.random(-dev,dev)*0.01))
	-- эй, есть там кто
	local radius = grenade_params[choosen].radius+1
	if not check_victims(npc,npc_pos,target_pos,radius,not see and memory_time>mid_enemy_memory_time and dev*0.01<radius) then	--,memory_time>mid_enemy_memory_time and dev*0.01<radius
		return false
	end
	--можно швыр€тьс€ - веро€тность никого не задеть (кроме врагов) достаточно велика
	self.a.from_vert = npc:level_vertex_id()
	self.a.from_pos = npc_pos
	self.a.target_point = target_pos
	self.a.grenade = choosen
	local from_dir = vector():sub(self.a.target_point,self.a.from_pos):normalize()
	self.a.grenades_from_pos = npc:bone_position("bip01_head"):add(from_dir:div(3))

	local obj = create_grenade(choosen.."_test", self.a.grenades_from_pos, npc:level_vertex_id(), npc:game_vertex_id())
	level.client_spawn_manager():add(obj.id,-1,throw,self.a)
	self.a.grenade_data = {time = 3000,section = choosen,test = true}
	self.wait_for_online = tg+600
	self.a.throwing_type = tg%3
	self.a.crouch = npc:body_state() == move.crouch
	self.test_grenade = obj.id
	self.a.test_end_time = nil
	self.testing = true
	if ui_grenade_marks then
		self.a.mark = be:id() == 0 and 'red' or npc:relation(actor) ~= game_object.enemy and 'green' or nil
	end
	return false
end
function evaluator_crazy_grenadier:death_callback()
	if self.test_grenade and grenades[self.test_grenade] then
		grenades[self.test_grenade].time = -1
		self.test_grenade = nil
	end
end

function evaluator_crazy_grenadier:update_test()
	local id = self.test_grenade
	local npc,st = self.object,self.a
	local sobj = sim:object(id)
	if not sobj then
		log("~[%s]test:fail sobj[%s], obj %s",npc:name(),id,get_grenade(id))
		return false
	end
	local obj = id and get_grenade(id)
	if not obj then
		if self.wait_for_online > time_global() then
			return
		end
		log("~[%s]test:fail obj %s (%s)",npc:character_name(),id,sobj)
		return false
	end
	if not grenades[id] then
		log("~[%s]fail grenades[%s]",self.object:name(),id)
		return false
	end
	if obj:parent() then
		log("~[%s]test:fail [%s] parent %s",npc:name(),obj:name(),obj:parent():name())
		return false
	end
	if not self.a.test_end_time then
		self.a.test_end_time = time_global() + grenade_params[grenades[id].section].explode_time
	end
	local ps,vel = obj:get_physics_shell(),vector()
	ps:get_linear_vel(vel)
	if st.test_end_time < time_global() or vel:magnitude() < 0.1 then
		local pos = obj:position()
		local radius = grenade_params[grenades[id].section].radius
		if npc:object(st.grenade) and pos:distance_to(st.target_point) < radius and check_victims(npc,st.from_pos,pos,radius,math.random()<0.5) then
			return true,pos
		end
		return false
	end
end

class "evaluator_aaa_grenade" (property_evaluator)
function evaluator_aaa_grenade:__init(storage,name) super (nil,name)
	self.a = storage
end
function evaluator_aaa_grenade:evaluate()
	if not self.a.evasion_enabled then
		return false
	end
	local npc,tg = self.object,time_global()
	if npc:critically_wounded() then
		return false
	end
	if self.danger_inert and self.danger_inert > tg then
		return true
	end
	if not npc:best_enemy() and db.storage[npc:id()].active_scheme == "remark" then
		return false
	end
	local npc_pos
	for k,v in pairs(grenades) do
		if not v.test and v.time > tg+200 then
			local grenade = get_grenade(k)
			if grenade then
				npc_pos = npc_pos or npc:position()
				local gdist = grenade:position():distance_to(npc_pos)
				if gdist < 25 then
					local radius = grenade_params[v.section].radius+2
					local who = v.initiator and get_grenade(v.initiator)
					if who and npc:relation(who) ~= game_object.enemy then	-- "сво€" граната
						if gdist < radius then
							local vel = vector()
							grenade:get_physics_shell():get_linear_vel(vel)
							if vel:magnitude() < 5 then
								self.a.danger = grenade:position():add(vel)
								self.a.danger_r = radius
								self.a.danger_id = grenade:id()
								self.a.danger_friendly = v.initiator ~= npc:id()
								self.last_danger_time = tg
								return true
							end
						end
					else
						if gdist < radius then
							self.a.danger = grenade:position()	--v.target
							self.a.danger_r = radius
							self.a.danger_id = grenade:id()
							self.a.danger_friendly = nil
							self.last_danger_time = tg
							return true
						elseif npc:see(grenade) and v.target:distance_to(npc_pos) < radius then
							self.a.danger = v.target
							self.a.danger_r = radius
							self.a.danger_id = grenade:id()
							self.a.danger_friendly = nil
							self.last_danger_time = tg
							return true
						end
					end
				end
			end
		end
	end
	if (self.last_danger_time or 0)+1000 > tg then
		if npc:position():distance_to(self.a.danger) < self.a.danger_r then
			self.danger_inert = tg+1500
			return true
		end
		self.a.danger = nil
		self.a.danger_r = nil
		self.last_danger_time = nil
	end
	return false
end

class "evaluator_psyh" (property_evaluator)
function evaluator_psyh:__init(npc,storage,name) super (nil,name)
	self.a = storage
	self.a.psyh_active = read_pstor('gr_psyh',nil,npc)
	if self.a.psyh_active == nil then
		self.a.psyh_active = write_pstor('gr_psyh',math.random() < psyh_chance,npc)	-- and not is_story_object(npc)
	end
	self.rand_time = math.random(4000,6000)
	self.a.psyh_delay = time_global()+10000
end
function evaluator_psyh:evaluate()
	if not self.a.psyh_active then
		return false
	end
	local npc = self.object
	if self.a.psyh_delay > time_global() then
		return false
	end
	local enemy = npc:best_enemy()
	if not enemy then
		self.a.psyh_delay = time_global() + 4200
		return false
	end
	if self.a.psyh_action then
		return true
	end
	self.a.psyh_delay = time_global() + self.rand_time
	if not (IsStalker(enemy) and (not psyh_actor_only or enemy:is_actor())) then
		return false
	end
	local time = time_global()-npc:memory_time(enemy)
	if time < 5000 and time >= 0 and npc:position():distance_to_sqr(npc:memory_position(enemy)) < psyh_init_dist then
		if not (self.a.psyh_grenade and npc:object(self.a.psyh_grenade)) then
			local avail_grenades = {}
			for sect,t in pairs(grenade_params) do
				local gr = npc:object(sect)
				if gr and t.kamikazze then
					table.insert(avail_grenades,sect)
				end
			end
			if #avail_grenades < 1 then
				return false
			end
			table.sort(avail_grenades,function(a,b) return grenade_params[a].radius > grenade_params[b].radius end)
			self.a.psyh_grenade = avail_grenades[1]
		end
		local lvid = enemy:level_vertex_id()
		if not npc:accessible(lvid) or level.vertex_position(lvid):distance_to_sqr(enemy:position()) > 4 then
			return false
		end
		self.a.psyh_delay = -1
		return true
	end
	return false
end

----------------------------------------------------------------------------------------------------------------------
-- ACTIONS
----------------------------------------------------------------------------------------------------------------------

class "action_fire_in_the_hole" (action_base)
function action_fire_in_the_hole:__init (storage,name) super (nil,name)
	self.a = storage
	self.aim_time = math.max(0, (1000 + math.random(2000)) / (1 + level.get_game_difficulty()) - 500 )
end
function action_fire_in_the_hole:initialize()
	action_base.initialize(self)
	self.at_pos = false
	self.begin_throw = false
	self.throw_end = false
	self.finalized = false
	self.time_back_to_pos = time_global()+5000

	local npc = self.object
	local wm = npc:get_wm(true)
	if wm then
		wm:disable()
	end
	state_mgr.lock(npc,true)
	npc:set_item(object.idle,npc:active_item())
	npc:set_desired_position()
	npc:set_desired_direction()
	npc:set_movement_type(move.run)
	npc:set_mental_state(anim.danger)
	npc:set_body_state(self.a.crouch and move.crouch or move.standing)
	npc:set_path_type(game_object.level_path)
	npc:clear_animations()
	npc:get_stalker():set_throw_target(self.a.target_point)
	ai_common.subscribe_for_events(npc:id(),self)
end
function action_fire_in_the_hole:execute()
	action_base.execute(self)
	if self.a.throwing == false then
		return
	end
	local npc = self.object

	if self.finalized then
		if npc:animation_count() == 0 then
			self.a.throwing = false
		end
		return
	end

	local grenade = self.a.grenade and npc:object(self.a.grenade)
	if not grenade then
		self.a.throwing = false
		return
	end

	npc:set_mental_state(anim.danger)
	local tg = time_global()

	if not self.at_pos then
		local npc_pos = npc:position()
		local dist = self.a.from_pos:distance_to(npc_pos)
		if dist < 2.4 then
			npc:set_sight(look.fire_point,self.a.target_point)
			npc:set_item(object.aim1,grenade)
			self.act_grenade = true
			if not self.sound then
				self.sound = m_sound.set_sound_play(npc,"grenade_ready",nil,3)
			end
		else
			local be = npc:best_enemy()
			if be and npc:see(be) then
				if IsStalker(be) and be:see(npc) then
					self.a.throwing = false
					return
				end
				npc:set_sight(be,true,true)
				local active_item = npc:active_item()
				if active_item and active_item:is_weapon_magazined() then
					if evaluators_id.fofl and self.storage:property(evaluators_id.fofl) then
						npc:set_item(object.aim1,active_item)
					else
						action_base.fire_(npc,active_item,be)
					end
				end
			elseif be and be:id()%2 == 0 then
				npc:set_sight(look.fire_point,self.a.target_point)
			else
				npc:set_sight(look.path_dir,nil,0)
			end
		end
		if tg > self.time_back_to_pos then
			self.a.throwing = false
			return
		end
		if (npc:path_completed() or dist < 0.5) and npc:active_slot() == GRENADE_SLOT then

			if not check_victims(npc,npc_pos,self.a.result_pos,grenade_params[self.a.grenade].radius) then
				self.a.throwing = false
				self.a.target_point = nil
				self.finalized = true
				return
			end

			local animtime1,animtime2,armtime
			npc:set_item(object.idle,grenade)
			npc:set_movement_type(move.stand)
			npc:clear_animations()
			if self.a.from_pos:distance_to(self.a.target_point) < grenade_max_dist*0.65 then
				if self.a.crouch then
					animtime1,animtime2,armtime = 1200,250,900
					npc:add_animation("cr_all_7_attack_0")
					npc:add_animation("cr_all_7_attack_1")
					npc:add_animation("cr_all_7_attack_1")
					npc:add_animation("cr_all_7_attack_1")
				else
					animtime1,animtime2,armtime = 1100,250,800
					npc:add_animation("norm_all_7_attack_0")
					npc:add_animation("norm_all_7_attack_1")
					npc:add_animation("norm_all_7_attack_1")
					npc:add_animation("norm_all_7_attack_1")
				end
				self.anim = 0
			else
				if self.a.crouch then
					animtime1,animtime2,armtime = 300,600,250
					npc:add_animation("cr_all_6_attack_0")
					npc:add_animation("cr_all_6_attack_1")
					npc:add_animation("cr_all_6_attack_1")
					npc:add_animation("cr_all_6_attack_1")
				else
					animtime1,animtime2,armtime = 300,500,250
					npc:add_animation("norm_all_6_attack_0")
					npc:add_animation("norm_all_6_attack_1")
					npc:add_animation("norm_all_6_attack_1")
					npc:add_animation("norm_all_6_attack_1")
				end
				self.anim = 1
			end

			self.throw_time = tg + animtime1 + self.aim_time
			self.end_time = self.throw_time + animtime2
			self.armed_time = tg + armtime

			self.at_pos = true
			return
		end
		npc:set_movement_type(move.run)
		npc:set_dest_level_vertex_id(self.a.from_vert)
		npc:set_desired_position(self.a.from_pos)
		return
	end

	npc:set_sight(look.point,self.a.target_point)

	if not self.sound_co and tg > self.armed_time-300 then
		grenade_params[self.a.grenade].snd_checkout:play(npc,grenade:position(),0,2.0)
		self.sound_co = true
	end

	if tg > self.throw_time and not self.begin_throw then
		npc:clear_animations()
		if self.a.crouch then
			npc:add_animation(self.anim == 1 and "cr_all_6_attack_2" or "cr_all_7_attack_2")
		else
			npc:add_animation(self.anim == 1 and "norm_all_6_attack_2" or "norm_all_7_attack_2")
		end
		self.begin_throw = true
		self.sound = nil
		return
	end

	if tg > self.end_time then
		local obj = create_grenade(grenade:section().."_fake",self.a.grenades_from_pos,npc:level_vertex_id(),npc:game_vertex_id())
		level.client_spawn_manager():add(obj.id,-1,throw,self.a)
		self.a.grenade_data = {section = grenade:section(),initiator = npc:id(),target = self.a.result_pos}
		delete_obj(grenade:id())
		self.a.grenade = nil
		self.act_grenade = nil
		self.a.next_check_time = tg + min_throw_interval
		self.finalized = true
		npc:activate_slot(NO_SLOT)
	end
end
function action_fire_in_the_hole:finalize()
	action_base.finalize(self)
	self.armed_time = nil
	self.sound_co = nil
	self.act_grenade = nil
	local npc = self.object
	if not npc:alive() then
		return
	end
	if not self.begin_throw then
		npc:clear_animations()
	end
	if npc:active_slot() == GRENADE_SLOT then
		npc:activate_slot(NO_SLOT)
	end
	if self.sound then
		m_sound.stop_sound_play(npc,3)
	end
	self.sound = nil
	ai_common.unsubscribe_from_events(npc:id(),self)
	npc:get_stalker():transfer_combat()
	state_mgr.lock(npc,false)
	local wm = npc:get_wm(true)
	if wm then
		wm:enable()
	end
end
function action_fire_in_the_hole:hit_callback(amount,dir,who,bone_id)
	if self.finalized then
		return
	end
	local npc = self.object
	if not (self.act_grenade or self.at_pos) then
		self.a.throwing = false
		self.a.next_check_time = time_global() + check_prd*3
		self.finalized = true
	elseif (bone_id == 0 and math.random() < amount or bone_id >= 31 and bone_id <= 43) and npc:active_slot() == GRENADE_SLOT then
		local grenade = npc:active_item()
		if grenade then
			npc:drop_item(grenade,6)
			if self.armed_time and self.armed_time < time_global() then
				grenade:set_fastcall(spoof_grenade,{time_global()+700,grenade:id(),grenade:name()})	--,self.armed_time-time_global(),who and who:id()
			end
		end
		self.a.throwing = false
		self.a.next_check_time = time_global() + min_throw_interval
		self.finalized = true
		self.act_grenade = nil
	elseif self.at_pos and not self.begin_throw then
		local et = self.throw_time - time_global()
		if et > 0 then
			self.throw_time = self.throw_time - et
			self.end_time = self.end_time - et
--			self.a.target_point:add(math.random(3,6))
		end
	end
end
function action_fire_in_the_hole:death_callback()
	local npc = self.object
	if npc and not self.finalized and self.armed_time and self.armed_time < time_global() and npc:active_slot() == GRENADE_SLOT then
		local grenade = npc:active_item()
		if grenade then
			grenade:set_fastcall(spoof_grenade,{time_global()+math.random(500,2000),grenade:id(),grenade:name()})	--,self.armed_time-time_global(),who and who:id()
		end
	end
end


class "action_run_from_grenade" (action_base)
function action_run_from_grenade:__init (storage,name) super (nil,name)
	self.a = storage
end
function action_run_from_grenade:initialize()
	action_base.initialize(self)
	self.a.throwing = false
	self.vid_time = 0
	local npc = self.object
	local wm = npc:get_wm(true)
	if wm then
		wm:disable()
	end
	state_mgr.lock(npc,true,true)
	m_sound.set_sound_play(npc,self.a.danger_friendly and "friendly_grenade" or "grenade_alarm",nil,3)
	if npc:weapon_unstrapped() then
		npc:set_item(object.idle,npc:best_weapon())
	end
	npc:set_desired_position()
	npc:set_desired_direction()
	npc:set_movement_type(move.run)
	npc:set_mental_state(anim.danger)
	npc:set_path_type(game_object.level_path)
	npc:clear_animations()
	ai_common.subscribe_for_events(npc:id(),self)
end
function action_run_from_grenade:execute()
	action_base.execute (self)
	if not self.a.danger then
		return
	end
	local npc = self.object

	if self.a.danger_id ~= self.id then
		self.id = self.a.danger_id
		self.vid = nil
	end

	local npc_pos,dvert = npc:position()
	local dist = npc_pos:distance_to(self.a.danger)
	if self.vid and self.vid_time > time_global() then
		dvert = self.vid
	else
		local cover = npc:best_cover(npc_pos, self.a.danger, 18, math.min(10,self.a.danger_r), 170)
		if cover and (cover:position():distance_to(self.a.danger) > self.a.danger_r or cover:position():distance_to(npc_pos) < dist) then
			dvert = cover:level_vertex_id()
		else
			local npc_lvid = npc:level_vertex_id()
			local best_dist = 0
			local dir = vector():sub(npc_pos,self.a.danger):normalize()
			for i,a in ipairs({0,15,-15,30,-30,50,-50,70,-70,90,-90,110,-110}) do
				local ndir = dir:rotate_y(a)
				local vert = npc:vertex_in_direction(npc_lvid,ndir,30)
				local ndist = level.vertex_position(vert):distance_to(self.a.danger)
				if ndist > best_dist then
					best_dist = ndist
					dvert = vert
					if ndist > self.a.danger_r+dist then
						break
					end
				end
			end
		end
		self.vid = dvert
		self.vid_time = time_global() + 4500
	end

	if self.fix_hit then
		self.fix_hit = nil
		return
	end

	npc:set_movement_type(move.run)
	if dvert and dist < self.a.danger_r*0.6 then
		npc:set_dest_level_vertex_id(dvert)
		if npc:path_completed() then
			npc:set_mental_state(anim.danger)
			npc:set_body_state(move.crouch)
		else
			npc:set_mental_state(anim.panic)
			npc:set_sight(look.path_dir,nil,0)
		end
		return
	end

	npc:set_mental_state(anim.danger)
	if dvert then
		npc:set_dest_level_vertex_id(dvert)
	else
		npc:set_dest_level_vertex_id(npc:level_vertex_id())
		npc:set_desired_position(npc_pos)
	end

	local be = npc:best_enemy()
	if be then
		if npc:see(be) then
			npc:set_sight(be,true,true)
			if evaluators_id.fofl and self.storage:property(evaluators_id.fofl) then
				npc:set_item(object.aim1,npc:active_item())
			else
				action_base.fire_(npc,npc:active_item(),be)
			end
		else
			if npc:path_completed() then
				npc:set_sight(look.point,npc:memory_position(be),true)
			else
				npc:set_sight(look.path_dir,nil,0)
			end
			npc:set_item(object.idle,npc:active_item())
		end
	elseif npc:weapon_unstrapped() then
		npc:set_item(object.idle,npc:active_item())
	end

	if npc:path_completed() then
		npc:set_body_state(move.crouch)
--		npc:set_movement_type(move.stand)
	end
end
function action_run_from_grenade:finalize()
	action_base.finalize(self)
	self.id = nil
	self.fix_hit = nil
	local npc = self.object
	if not npc:alive() then
		return
	end
	npc:set_mental_state(anim.danger)
	npc:set_item(object.idle,npc:active_item())
	npc:get_stalker():transfer_combat()
	ai_common.unsubscribe_from_events(npc:id(),self)
	state_mgr.lock(npc,false)
	local wm = npc:get_wm(true)
	if wm then
		wm:enable()
	end
end
function action_run_from_grenade:hit_callback(amount,dir,who,bone_id)
	if bone_id > 0 or amount < 0.05 then
		return
	end
	local npc = self.object
	if math.random() < amount+0.1 then
		ai_animation.play(npc,{animation = "wounded_2_out",weapon = object.drop,sound_theme = 'npc_hit',mental = anim.danger})
		return
	end
	npc:set_mental_state(anim.danger)
	npc:set_movement_type(move.stand)
	self.fix_hit = true
end


class "action_psyh" (action_base)
function action_psyh:__init (storage,name) super (nil,name)
	self.a = storage
end
function action_psyh:initialize()
	action_base.initialize(self)
	local npc = self.object
	local wm = npc:get_wm(true)
	if wm then
		wm:disable()
	end
	state_mgr.lock(npc,true,true)
	npc:set_desired_position()
	npc:set_desired_direction()
	npc:set_movement_type(move.run)
	npc:set_mental_state(anim.danger)
	npc:set_body_state(move.standing)
	npc:set_path_type(game_object.level_path)
	npc:clear_animations()
	npc:get_stalker():set_throw_target(npc:position())
	self.a.psyh_action = true
	ai_common.subscribe_for_events(npc:id(),self)
end
function action_psyh:execute()
	action_base.execute(self)
	local npc = self.object
	local enemy = npc:best_enemy()
	if not enemy or ai_wounded.is_wounded(enemy) or not IsStalker(enemy) then
		self.a.psyh_action = nil
		self.a.psyh_delay = time_global()+5000
		return
	end
	local actual = time_global()-npc:memory_time(enemy) < 1000
	if not self.lvid or actual then
		self.lvid = enemy:level_vertex_id()
	end
	if not npc:accessible(self.lvid) or level.vertex_position(self.lvid):distance_to_sqr(enemy:position()) > 5 then
		self.a.psyh_action = nil
		self.a.psyh_delay = time_global()+2000
		return
	end
	local grenade = self.a.psyh_grenade and npc:object(self.a.psyh_grenade)
	if not grenade then
		self.a.psyh_grenade = nil
		self.a.psyh_action = nil
		self.a.psyh_delay = time_global()+1000
		return
	end

	local pos = npc:memory_position(enemy)
	local dist = npc:position():distance_to(pos)

	npc:set_dest_level_vertex_id(self.lvid)
	npc:set_desired_position(pos)

	if npc:path_completed() and npc:level_vertex_id() == self.lvid and not actual then
		self.a.psyh_action = nil
		self.a.psyh_delay = time_global()+6000
		return
	end

	if dist > psyh_grenade_dist then	-- сближение
		local wpn = npc:best_weapon()
		if npc:see(enemy) then
			npc:set_sight(enemy,true,true)
			action_base.fire_(npc,wpn,enemy,dist)
		else
			npc:set_sight(look.path_dir,nil,0)
			npc:set_item(object.idle,wpn)
		end
		npc:set_mental_state(anim.danger)
		self.armed_time = nil
		return
	end

	m_sound.set_sound_play(npc,"psyh_threat",nil,3)
	npc:set_sight(look.path_dir,nil,0)
	npc:set_item(object.idle,grenade)
	if npc:active_slot() == GRENADE_SLOT then
		npc:set_mental_state(anim.panic)
	end

	if actual and not self.armed_time and dist < math.min(10,grenade_params[self.a.psyh_grenade].radius+1) then
		self.armed_time = time_global()
		grenade_params[self.a.psyh_grenade].snd_checkout:play(npc,grenade:position(),0,2.5)
	end

	if npc:see(enemy) and dist < 3 or npc:position():distance_to(enemy:position()) < 2.5 then
		if npc:id()%2 == 0 then
			npc:drop_item(grenade,1)
			if self.armed_time then
				grenade:set_fastcall(spoof_grenade,{time_global()+500,grenade:id(),grenade:name(),self.armed_time and self.armed_time-time_global()})
			end
			self.a.psyh_grenade = nil
			self.a.psyh_action = nil
			self.a.psyh_delay = time_global()+400
			return
		else
			npc:set_mental_state(anim.danger)
		end
	end

	if self.armed_time and time_global()-self.armed_time > grenade_params[self.a.psyh_grenade].explode_time then
		local obj = create_grenade(self.a.psyh_grenade.."_fake", npc:bone_position("bip01_r_hand"), npc:level_vertex_id(), npc:game_vertex_id())
		level.client_spawn_manager():add(obj.id,-1,explode,{section = self.a.psyh_grenade,initiator = npc:id()})
		delete_obj(grenade:id())
		self.a.psyh_grenade = nil
		self.a.psyh_action = nil
		self.a.psyh_delay = time_global()+5000
	end
end
function action_psyh:finalize()
	action_base.finalize(self)
	local npc = self.object
	self.a.psyh_action = nil
	self.lvid = nil
	if not npc:alive() then
		return
	end
	local slot = npc:active_slot()
	if slot == GRENADE_SLOT then
		npc:activate_slot(NO_SLOT)
		local grenade = npc:active_item()
		if grenade and self.armed_time then
			local enemy = npc:best_enemy()
			local pos = enemy and npc:memory_position(enemy)
			if pos and pos:distance_to(npc:position()) < 20 then
				local obj = create_grenade(grenade:section().."_fake",npc:bone_position("bip01_head"),npc:level_vertex_id(),npc:game_vertex_id())
				local d = {section = grenade:section(),target = pos,time = self.armed_time-time_global()}
				level.client_spawn_manager():add(obj.id,-1,throw,{grenade_data = d,throwing_type = 0,target_point = pos,mark = enemy:is_actor() and 'red' or nil})
				npc:play_cycle("norm_all_6_attack_2",true)
				delete_obj(grenade:id())
			end
		end
	end
	self.armed_time = nil
	if self.a.psyh_delay <= time_global() then
		self.a.psyh_delay = time_global()+500
	end
	ai_common.unsubscribe_from_events(npc:id(),self)
	npc:get_stalker():transfer_combat()
	state_mgr.lock(npc,false)
	local wm = npc:get_wm(true)
	if wm then
		wm:enable()
	end
end
function action_psyh:hit_callback(amount,dir,who,bone_id)
	local npc = self.object
	if bone_id >= 31 and bone_id <= 43 and npc:active_slot() == GRENADE_SLOT then
		local grenade = npc:active_item()
		if grenade then
			npc:drop_item(grenade,1)
			if self.armed_time then
				grenade:set_fastcall(spoof_grenade,{time_global()+500,grenade:id(),grenade:name(),self.armed_time-time_global()})
			end
		end
		self.a.psyh_grenade = nil
		self.a.psyh_action = nil
	end
end
function action_psyh:death_callback()
	local npc = self.object
	if npc and self.armed_time and npc:active_slot() == GRENADE_SLOT then
		local grenade = npc:active_item()
		if grenade then
			grenade:set_fastcall(spoof_grenade,{time_global()+math.random(500,2000),grenade:id(),grenade:name()})	--,self.armed_time-time_global(),who and who:id()
		end
	end
end

----------------------------------------------------------------------------------------------------------------------
-- HELPERS
----------------------------------------------------------------------------------------------------------------------

function check_victims(npc,self_pos,pos,radius,want_enemy)	-- нет ли в радиусе поражени€ друзей; а враги есть?
	radius = radius+1
	radius = radius*radius
	if self_pos:distance_to_sqr(pos) < radius then
		return false
	end
	local nid,enemy = npc:id()
	local sst,mst = modules.stype_stalker,modules.stype_mobile
	local stalker = npc:get_stalker()
	for id,t in pairs(db.storage) do
		if (t.stype == sst or t.stype == mst or id == actor_id) and id ~= nid then
			local obj = get_grenade(id)
			if obj and obj:alive() then
				if obj:position():distance_to_sqr(pos) < radius then
					if npc:relation(obj) == game_object.enemy then
						if not stalker:is_tolerant(obj) then
							enemy = true
						end
					else
						return false
					end
				end
			end
		end
	end
	if want_enemy then
		return enemy
	else
		return true
	end
end

function spawn_grenade(eva)
	local npc = eva.object
	if time_global() > eva.spawn_update_time then
		eva.spawn_update_time=time_global()+spawn_period+math.random(spawn_period*0.1)-spawn_period*level.get_game_difficulty()*spawn_period_gd_factor
--		log("#spawn_grnade[%s] set time %s , chance %s",npc:character_name(),(eva.spawn_update_time-time_global())/1000,spawn_chance_base+eva.a.rank*spawn_chance_rank_factor)
		if spawn_chance_base+eva.a.rank*spawn_chance_rank_factor < math.random() and npc:best_weapon() then
			return
		end
		local cnt,ht = 0,{}
		for s,_ in pairs(grenade_params) do
			local gr = npc:object(s)
			if gr then
				cnt = cnt+1
				if cnt >= max_grenade_num then
					return
				end
				ht[s] = true
			end
		end
		local spch,cn = {},0
		for s,c in pairs(eva.a.sets.spawn_grenades) do
			if not ht[s] then
				cn = cn + c
				table.insert(spch,{s,cn})
			end
		end
		local rnd = math.random()
		for _,t in ipairs(spch) do
			if rnd < t[2] then
				log("spawn_grenade[%s]:create %s",npc:character_name(),t[1])
				sim:create(t[1],npc:position(),npc:level_vertex_id(),npc:game_vertex_id(),npc:id())
				return
			end
		end
	end
end

function throw(st,id,obj)
	log("throw %s[%s]",obj,id)
	local ps = obj:get_physics_shell()
	if ps == nil then
		log("!try to throw[%s] no ps! parent %s typ %s",obj:name(),obj:parent(),typ)
		return
	end
	if st.grenade_data.test then
		if _DEBUG_ then level.map_add_object_spot(id,"red_location","") end
	elseif ui_grenade_marks then
		add_new_marker(id,st.mark)
	else
		level.map_add_object_spot(id,"grenade_location","grenade")
	end
	if st.throwing_type then
		local dir = vector():sub(st.target_point,obj:position())
		if st.throwing_type == 0 then
			dir:mul(160)
			dir:add(vector():set(0,900,0))
		elseif st.throwing_type == 1 then
			dir:mul(125)
			dir:add(vector():set(0,1900,0))
		elseif st.throwing_type == 2 then
			dir:mul(110)
			dir:add(vector():set(0,2600,0))
		else
			dir:mul(250)
		end
		dir:mul(obj:mass())
		log("throw[%s] force %s dist %s mass %s",obj:name(),dir:magnitude(),st.target_point:distance_to(obj:position()),obj:mass())
		local bone = ps:get_element_by_bone_name("wpn_body")
		if bone then
			bone:apply_force(dir.x,dir.y,dir.z)
		end
	end
	st.grenade_data.time = time_global() + grenade_params[st.grenade_data.section].explode_time + (st.grenade_data.time or 0)
	grenades[id] = st.grenade_data
	st.grenade_data = nil
end

function explode(data,id,obj)
	log("explode %s[%s] initiator [%s]",obj,id,data.initiator)
	if grenade_params[data.section].aff then
		grenade_params[data.section].aff(obj,data)
	end
	if data.initiator then
		obj:explode(data.initiator)
	else
		obj:explode()
	end
end

-- 1 - врем€ подмены, 2 - object id, 3 - object name, 4(опц) - добавка к задержке взрыва, 5(опц) - initiator id
function spoof_grenade(t)
	if t[1] < time_global() then
		local sobj,gobj = sim:object(t[2]),get_grenade(t[2])
		if sobj and gobj and sobj:name() == t[3] then	-- and not gobj:parent()
			local obj = create_grenade(gobj:section().."_fake",gobj:position(),gobj:level_vertex_id(),gobj:game_vertex_id())
			local d = {section = gobj:section(),target = sobj.position,time = t[4],initiator = t[5]}
			level.client_spawn_manager():add(obj.id,-1,throw,{grenade_data = d})
			sim:release(sobj)	--delete_obj(sobj.id)
		end
		return true
	end
	return false
end

function create_grenade(section,pos,lv,gv)
	local obj = sim:create(section,pos,lv,gv)
	obj = sim:object(obj.id)
	obj.m_flags:set(global_flags.flSwitchOnline,	true)
	obj.m_flags:set(global_flags.flSwitchOffline,	false)
	obj.m_flags:set(global_flags.flVisibleForAI,	false)
	obj.m_flags:set(global_flags.flUsefulForAI,		false)
	obj.m_flags:set(global_flags.flUsedAI_Locations,false)
	obj.m_flags:set(global_flags.flCanSave,			false)
	return obj
end

function update(a)-- {time,delta,binder}
	for id,data in pairs(grenades) do
		if a.time > data.time then
			local sobj = sim:object(id)
			if sobj then
				if data.test then
					sim:release(sobj)
				else
					local obj = get_grenade(id)
					if obj then
						explode(data,id,obj)
						if ui_grenade_marks then
							start_fading(id)
						else
							level.map_remove_object_spot(id,"grenade_location")
						end
					else
--						log("!explode[%s] fail: not obj!!!!!!!!",sobj:name())
					end
				end
				grenades[id] = nil
			else	-- возможно граната взорвалась сама?
--				log("!update[%s] not sobj %s !!!!",id)
				grenades[id] = nil
				if ui_grenade_marks then
					start_fading(id)
				end
			end
		end
	end
	if ui_grenade_marks then
		update_grenade_marks()
	end
end

----------------------------------------------------------------------------------------------------------------------
-- GRENADE MARKS
-- Description : установка маркера на кинутую гранату в стиле «ѕ
-- Authors : Charsi, Rulix
----------------------------------------------------------------------------------------------------------------------

local wnd,xml
local initial_spot,initial_spot_overdist,mark_dist
local colors = {
black	= {10,10,10},
full	= {255,255,255},
red		= {180,60,90},
green	= {60,180,90},
}
local grenade_marks = {}

-- добавление маркера дл€ объекта по его id
function add_new_marker(obj_id,color)
	local obj = get_grenade(obj_id)
	if not obj then
		return
	end
	local dir = obj:position():sub(actor:position())
	local dist = dir:magnitude()
	if dist < 100 then
		if not wnd then
			wnd = CUIScriptWnd()
			xml = CScriptXmlInit()
			get_hud():AddDialogToRender(wnd)
			xml:ParseFile("grenade_mark.xml")
			initial_spot = level.get_game_difficulty() < 2
			initial_spot_overdist = level.get_game_difficulty() < 1
			mark_dist = 35-5*level.get_game_difficulty()
		end
		local mark_st = xml:InitStatic("mark",wnd)
		local sdir = device().cam_dir
		local angle = math.atan2(-sdir.x,sdir.z)
		local c,s = math.cos(angle), math.sin(angle)
		mark_st:SetHeading( - math.atan2(dir.x * c + dir.z * s,-dir.x * s + dir.z * c) )
		local clr = colors[color] or colors.full
		local a = (initial_spot_overdist or initial_spot and dist <= mark_dist) and 255 or 1
		mark_st:SetColor(GetARGB(a,clr[1],clr[2],clr[3]))
		table.insert(grenade_marks,obj_id,{st=mark_st,a=a,ta=a,c=clr})
	end
end

local s,c,apos
-- обновление статиков
function update_grenade_marks()
	for id,t in pairs(grenade_marks) do
		if not s then
			local sdir = device().cam_dir
			local angle = math.atan2( -sdir.x , sdir.z )
			c = math.cos(angle)
			s = math.sin(angle)
			apos = actor:position()
		end
		if t.a > t.ta then
			t.a = t.a-(t.rem and 4 or 2) > t.ta and t.a-(t.rem and 4 or 2) or t.ta
		elseif t.a < t.ta then
			t.a = t.a+3 < t.ta and t.a+3 or t.ta
		end
		t.st:SetColor(GetARGB(t.a,t.c[1],t.c[2],t.c[3]))
		local obj = get_grenade(id)
		if not obj or t.rem and t.a < 5 then
			wnd:DetachChild(t.st)
			grenade_marks[id] = nil
		else
			local dir = obj:position():sub(apos)
			t.st:SetHeading( - math.atan2(dir.x * c + dir.z * s, - dir.x * s + dir.z * c) )
			if not t.rem then
				local dist = dir:magnitude()-3
				t.ta = dist > mark_dist and 0 or dist < 0 and 255 or 255-math.ceil(224*dist/mark_dist)
			end
		end
	end
	if s then s = nil end
end

-- затухание маркера
function start_fading(obj_id)
	if grenade_marks[obj_id] then
		grenade_marks[obj_id].ta = 0
		grenade_marks[obj_id].rem = true
	else
		log("start_fading: not grenade_marks[%s]",obj_id)
	end
end

-- детач статиков при выгрузке уровн€
function remove_grenade_marks()
	if wnd then
		get_hud():RemoveDialogToRender(wnd)
	end
end
----------------------------------------------------------------------------------------------------------------------
-- BINDER
----------------------------------------------------------------------------------------------------------------------
function init()
	event("presets"):register(presets)
end
function presets()
	event("npc_spawn"):register(add_to_binder)
	event("activate_by_section"):register(reset_scheme)
	event("actor_update"):register(update)
	event("actor_destroy"):register(remove_grenade_marks)
end

local evid_crazy_grenadier = evaluators_id('grenadier',false)
local evid_aaa_grenade = evaluators_id('grenade_evade',false)
local evid_psyh = evaluators_id('grenade_psyh')

actions_id('grenadier')
actions_id('grenade_evade')
actions_id('grenade_psyh')

function add_to_binder(t)
	local npc = t.obj
	local manager = t.st.planner
	local storage = t.st.ai('grenadier')
	local psyh = psyh_comms[npc:character_community()]
	-- Evaluators
	if forbidden_factions[npc:character_community()] or forbidden_npcs[npc:name()] or forbidden_npcs[npc:profile_name()] then
		manager:add_evaluator	(evid_crazy_grenadier, property_evaluator_const(false))
		manager:add_evaluator	(evid_aaa_grenade, property_evaluator_const(false))
		manager:add_evaluator	(evid_psyh, property_evaluator_const(false))
		return
	else
		manager:add_evaluator	(evid_crazy_grenadier, evaluator_crazy_grenadier(npc,storage,manager,"crazy_grenadier"))
		manager:add_evaluator	(evid_aaa_grenade, evaluator_aaa_grenade(storage,"aaa_grenade"))
		if psyh then
			manager:add_evaluator (evid_psyh, evaluator_psyh(npc,storage,"aaa_grenade"))
		else
			manager:add_evaluator (evid_psyh, property_evaluator_const(false))
		end
	end
	-- Actions
	local wp = world_property
	local action				= action_fire_in_the_hole(storage,"fire_in_the_hole")
	action:add_precondition		(wp(evaluators_id.sidor_wounded_base, false))
	action:add_precondition		(wp(evaluators_id.state_mgr+3, true))
	action:add_precondition		(wp(evid_aaa_grenade, false))
	if evaluators_id.bandage then
		action:add_precondition	(wp(evaluators_id.bandage,false))
	end
	if evaluators_id.facer then
		action:add_precondition	(wp(evaluators_id.facer,false))
	end
	if evaluators_id.gl_fire then
		action:add_precondition	(wp(evaluators_id.gl_fire,false))
	end
	action:add_precondition		(wp(evid_crazy_grenadier, true))
	action:add_effect			(wp(evid_crazy_grenadier, false))
	manager:add_action			(actions_id.grenadier, action)

	action						= action_run_from_grenade(storage,"run_from_grenade")
	action:add_precondition		(wp(evaluators_id.sidor_wounded_base, false))
--	action:add_precondition		(wp(evid_crazy_grenadier, false))
	action:add_precondition		(wp(evid_psyh, false))
	action:add_precondition		(wp(evid_aaa_grenade, true))
	action:add_effect			(wp(evid_aaa_grenade, false))
	manager:add_action			(actions_id.grenade_evade, action)

	if psyh then
		action					= action_psyh(storage,"kamikazze")
		action:add_precondition	(wp(evaluators_id.sidor_wounded_base, false))
	--	action:add_precondition	(wp(evid_crazy_grenadier, false))
		if evaluators_id.gl_fire then
			action:add_precondition	(wp(evaluators_id.gl_fire,false))
		end
		action:add_precondition	(wp(evid_psyh, true))
		action:add_effect		(wp(evid_psyh, false))
		manager:add_action		(actions_id.grenade_psyh, action)
	end

	-- включение в планировщик
	for i,id in ipairs{stalker_ids.action_combat_planner} do
		action = manager:action(id)
		action:add_precondition(wp(evid_crazy_grenadier,false))
		action:add_precondition(wp(evid_aaa_grenade,false))
		if psyh then action:add_precondition(wp(evid_psyh,false)) end
	end
	for i,id in ipairs{actions_id.alife,stalker_ids.action_danger_planner} do
		action = manager:action(id)
		action:add_precondition(wp(evid_aaa_grenade,false))
	end
end

function reset_scheme(a)
	if not a.is_stalker then
		return
	end
	local st,section = a.st,a.section
	local profile
	if section and st.ini:line_exist(section,"grenadier") then
		profile = st.ini:r_string(section,"grenadier")
	elseif section and st.ini:line_exist(st.section_logic,"grenadier") then
		profile = st.ini:r_string(st.section_logic,"grenadier")
	else
		profile = a.obj:character_community()
	end
	local a = st.ai('grenadier')
	if a.current_profile ~= profile then
		a.current_profile = profile
		local p = read_profile(profile)
		a.throw_enabled = p.throw
		a.evasion_enabled = p.evasion
		a.sets = p
	end
end
