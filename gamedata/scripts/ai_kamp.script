----------------------------------------------------------------------------------------------------------------------
--    Схема лагерь. Чудак(и) у костра.
--    автор: Диденко Руслан (Stohe)
----------------------------------------------------------------------------------------------------------------------

_DEBUG_ = true --// file under debugging?
kamps = {}
kamp_stalkers = {} -- могут ли сталкеры в лагере юзаться игроком.
-- Объявления итераторов
local k,v,kk,vv = 0,0,0,0
---------------------------------------------------------------------------------------------------------------------
--Evaluators
----------------------------------------------------------------------------------------------------------------------
--' Условие завершения скрипта
class "evaluator_kamp_end" (property_evaluator)
function evaluator_kamp_end:__init(name, storage) super (nil, name)
    self.a = storage
end
function evaluator_kamp_end:evaluate()
    return not xr_logic.is_active(self.object, self.a)
end
--' Находимся ли мы на заданной позиции
class "evaluator_on_position" (property_evaluator)
function evaluator_on_position:__init(name, storage) super (nil, name)
    self.a = storage
end
function evaluator_on_position:evaluate()
    if self.object:level_vertex_id() == self.a.pos_vertex  then
        return true
    end
	if self.a.pos_vector and self.object:target_movement_type() == move.stand and self.object:position():distance_to_sqr(self.a.pos_vector) < 2 then
		return true
	end
    return false
end
----------------------------------------------------------------------------------------------------------------------
--Actions
----------------------------------------------------------------------------------------------------------------------
--' Идет в заданную область
class "action_go_position" (action_base)
function action_go_position:__init (npc_name,action_name,storage) super (nil,action_name)
    self.a = storage
end
function action_go_position:initialize()
    action_base.initialize(self)
    self.object:set_desired_position()
    self.object:set_desired_direction()
    self.a.pos_vertex = nil
end
function action_go_position:execute ()
    action_base.execute (self)
    if xr_logic.try_switch_to_another_section(self.object, self.a) then
        return
    end

	if self.a.pos_vertex and self.keep_vertex and self.object:accessible(self.a.pos_vertex) then
		return
	end

    local tmp_pos_vertex,keep = kamps[self.a.center_point]:getDestVertex(self.object:id(), self.a.radius)
	self.keep_vertex = keep

	if not self.object:accessible(tmp_pos_vertex) then
--		log("[%s] KAMP NODE NOT ACCESSIBLE. Get accessible nearest", self.object:name())
		tmp_pos_vertex = self.object:accessible_nearest(level.vertex_position(self.a.pos_vertex), vector():set(0,0,0))
		self.keep_vertex = nil
	end

    if self.a.pos_vertex == tmp_pos_vertex then
		return
	end
	self.a.pos_vertex = tmp_pos_vertex

	self.a.look_pos = level.vertex_position(patrol(self.a.center_point):level_vertex_id(0)):add(vector():set(math.random(-7,7)/10,0,math.random(-7,7)/10))
	self.a.pos_vector = level.vertex_position(self.a.pos_vertex)
	self.object:set_dest_level_vertex_id(self.a.pos_vertex)
	self.object:set_desired_direction(vector():sub(self.a.look_pos,level.vertex_position(self.a.pos_vertex)))
	self.object:set_path_type(game_object.level_path)
	state_mgr.set_state(self.object, self.a.def_state_moving)
end
function action_go_position:finalize ()
    action_base.finalize (self)
end

--' Просто сидит и втыкает
class "action_wait" (action_base)
function action_wait:__init (npc_name,action_name,storage) super (nil,action_name)
    self.a = storage
	self.enable_torch = false
end
function action_wait:initialize()
    action_base.initialize(self)
    self.object:set_desired_position()
    self.object:set_desired_direction()
    kamps[self.a.center_point]:increasePops(self.object)
--	kamps[self.a.center_point]:checkNpcAbility(self.object)
end
function action_wait:activate_scheme()
	self.a.signals = {}
end
function action_wait:execute()
    action_base.execute(self)
    if xr_logic.try_switch_to_another_section(self.object, self.a) then
        return
    end
    local state, sound, substate = kamps[self.a.center_point]:updateNpc(self.object)

    --' повернуть его лицом к центру
    state_mgr.set_state(self.object, state, nil, nil, {look_position = self.a.look_pos,accuracy = 1.2}, nil, nil, {subanim = substate})
	if sound then
		m_sound.set_sound_play(self.object, sound)
	end
end
function action_wait:finalize()
    action_base.finalize(self)
	local npc = self.object
    kamps[self.a.center_point]:decreasePops(npc)
	if npc:alive() then
		local snd = m_sound.current_sound(npc)
		if snd and (snd.section == 'harmonica' or snd.section == 'guitar') then
			m_sound.stop_sound_play(npc)
		end
		return
	end
end
function action_wait:deactivate(npc)
    kamps[self.a.center_point]:removeNpc(npc)
end
function action_wait:death_callback(npc)
    kamps[self.a.center_point]:removeNpc(npc)
end
function action_wait:net_destroy(npc)
    kamps[self.a.center_point]:removeNpc(npc)
end


class "CKampManager"
function CKampManager:__init(path)
    self.kamp_name = path
    self.patrol = patrol(path)
    self.center = self.patrol:level_vertex_id(0)
    self.position = {{dir = vector():set(1, 0, 0),    used = nil},
                     {dir = vector():set(1, 0, 1),    used = nil},
                     {dir = vector():set(0, 0, 1),    used = nil},
                     {dir = vector():set(-1, 0, 1),    used = nil},
                     {dir = vector():set(-1, 0, 0),    used = nil},
                     {dir = vector():set(-1, 0, -1),used = nil},
                     {dir = vector():set(0, 0, -1),    used = nil},
                     {dir = vector():set(1, 0, -1),    used = nil}}
    self.npc = {}
    self.population = 0
    self.kamp_state = "idle"
    -- Где то здесь распарсим патрульный путь и проапдейтим вектор позиций.
    -- 0 вершина - центр лагеря.
    -- 1 флаг - сектор занят, в поинте можно сидеть.
    -- 2 флаг - сектор занят, в поинте нельзя сидеть.
    for k = 1, self.patrol:count() - 1 do
        -- если есть 1 или 2 флажок - отметить сектор как занятый
        if self.patrol:flag(k,1) or
           self.patrol:flag(k,2)
        then
            -- отметить сектор как занятый
            for key,value in pairs(self.position) do
                dir = vector():sub(level.vertex_position(self.patrol:level_vertex_id(k)), level.vertex_position(self.center))
                if value.dir then
                    yaw = vector.yaw_deg(dir, value.dir)
                    if yaw <=23 then
                        --'printf("KAMP node[%s], sector[%s,] yaw[%s]", k, key, vector.yaw_deg(dir, value.dir))
                        value.used = -1
                        break
                    end
                end
            end

        end

        -- если есть 1 флажок - создать место для сидения в точке пути
        if self.patrol:flag(k,1) then
            -- создать точку для сидения
            table.insert(self.position, {vertex = self.patrol:level_vertex_id(k)})
        end
    end
    --log1(table.tree(self.position))
    --Таблица соответствий состояния лагеря и допустимых анимаций и звуков.
    self.avail_state = {idle                = { directed    = { "wait", "sit", "sit_ass", "sit_knee", "eat_kolbasa", "eat_vodka", "eat_energy", "eat_bread", "trans"}},
                        pre_harmonica        = { directed    = { "wait_harmonica"},
                                                undirected    = { "wait", "sit", "sit_ass", "sit_knee", "eat_kolbasa", "eat_vodka", "eat_energy", "eat_bread", "trans"}},
                        harmonica            = { directed    = { "play_harmonica"},
                                                undirected    = { "wait", "sit", "sit_ass", "sit_knee", "eat_kolbasa", "eat_vodka", "eat_energy", "eat_bread", "trans"}},
                        post_harmonica        = { directed    = { "wait_harmonica"},
                                                undirected    = { "wait", "sit", "sit_ass", "sit_knee", "eat_kolbasa", "eat_vodka", "eat_energy", "eat_bread", "trans"}},
                        pre_guitar            = { directed    = { "wait_guitar"},
                                                undirected    = { "wait", "sit", "sit_ass", "sit_knee", "eat_kolbasa", "eat_vodka", "eat_energy", "eat_bread", "trans"}},
                        guitar                = { directed    = { "play_guitar"},
                                                undirected    = { "wait", "sit", "sit_ass", "sit_knee", "eat_kolbasa", "eat_vodka", "eat_energy", "eat_bread", "trans"}},
                        post_guitar            = { directed    = { "wait_guitar"},
                                                undirected    = { "wait", "sit", "sit_ass", "sit_knee", "eat_kolbasa", "eat_vodka", "eat_energy", "eat_bread", "trans"}},
                        pre_joke            = { directed    = { "declarate"},
                                                undirected    = { "wait", "sit", "sit_ass", "sit_knee", "eat_kolbasa", "eat_vodka", "eat_energy", "eat_bread", "trans"}},
                        joke                = { directed    = { "declarate"},
                                                undirected    = { "wait", "sit", "sit_ass", "sit_knee", "eat_kolbasa", "eat_vodka", "eat_energy", "eat_bread", "trans"}},
                        post_joke            = { directed    = { "declarate"},
                                                undirected    = { "wait", "sit", "sit_ass", "sit_knee", "eat_kolbasa", "eat_vodka", "eat_energy", "eat_bread", "trans"}}}
    self.avail_sound = {idle                = { directed = "idle"},
                        pre_harmonica        = { directed = "pre_harmonica", undirected = ""},
                        harmonica            = { directed = "play_harmonica", undirected = ""},
                        post_harmonica        = { directed = "", undirected = "reac_harmonica"},
                        pre_guitar            = { directed = "pre_guitar", undirected = ""},
                        guitar                = { directed = "play_guitar", undirected = ""},
                        post_guitar            = { directed = "", undirected = "reac_guitar"},
                        pre_joke            = { directed = "pre_joke", undirected = ""},
                        joke                = { directed = "play_joke", undirected = ""},
                        post_joke            = { directed = "", undirected = "reac_joke"}}
    -- Таблица таймаутов по состоянию. Если состояние установилось, то некоторое время оно не может быт изменено.
    self.timeout     = {idle                = { min = 25000 },
                        pre_harmonica        = { min = 3000 },
                        harmonica            = { min = 10000 },
                        post_harmonica        = { min = 5000 },
                        pre_guitar            = { min = 3000 },
                        guitar                = { min = 10000 },
                        post_guitar            = { min = 5000 },
                        pre_joke            = { min = 3000 },
                        joke                = { min = 5000 },
                        post_joke            = { min = 8000 }}
    -- Таблица глобальных состояний лагеря.
    self.kamp_states = { idle = true,
                         pre_harmonica = false, harmonica = false, post_harmonica = false,
                         pre_guitar = false, guitar = false, post_guitar = false,
                         pre_joke = true, joke = true, post_joke = true}
    -- Таблица допустимых переходов между состояниями с вероятностями.
    self.trans_kamp = { idle            = { idle = 15, pre_harmonica = 15, pre_guitar = 30, pre_joke = 40 },
                        pre_harmonica    = { harmonica = 100 },
                        harmonica        = { post_harmonica = 100 },
                        post_harmonica    = { idle = 80, harmonica = 20 },
                        pre_guitar        = { guitar = 100 },
                        guitar            = { post_guitar = 100 },
                        post_guitar        = { idle = 70, guitar = 30 },
                        pre_joke        = { joke = 100 },
                        joke            = { post_joke = 100 },
                        post_joke        = { idle = 100 }}
    -- Хранилище для режиссера лагеря. Режиссерем является сталкер, затеявший необычное поведение
    self.director = nil
end
function CKampManager:selectPosition(npc_id)
    -- создаем список доступных позиций
    --printf("KAMP. [%s] called select position", npc_id)
    local free = {}
    for k,v in pairs(self.position) do
        if v.used == nil then
            table.insert(free, k)
        end
    end
    --' затем из доступных позиций выбрать рандомно одну.
    if #free > 0 then
        --printf("KAMP [%s] free node > 0", npc_id)
        local rr = math.random(#free)
        self.position[free[rr]].used = npc_id
        self.npc[npc_id].position = free[rr]
    end
end
function CKampManager:getDestVertex(npc_id, radius)
    --printf("get dest Vertex called [%s]", npc_id)
    if self.npc[npc_id].position == nil then
        printf("-------debug_info-------------")
        log1(table.tree(self.npc))
        printf("-------debug_info-------------")
        log1(table.tree(self.position))
        printf("-------debug_info-------------")
        abort("get dest Vertex: nil [%s]", npc_id)
        return nil
    end

    local position = self.position[self.npc[npc_id].position]
    if position.vertex ~= nil then
        --printf("vertex preselected [%s]", npc_id)
        return position.vertex
    end
    -- высчитываем вертех по направлению
    local pp = level.vertex_in_direction(self.center, position.dir, radius)
    pp = level.vertex_in_direction(pp, vector():set(math.random(-1,1), 0, math.random(-1,1)), math.random(0,radius/4))
    --printf("vertex selected [%s]", npc_id)
    return pp,true
end
function CKampManager:proceedState(npc)
    -- Проверка на таймаут
    if self.begin ~= nil and
       time_global() - self.begin < self.timeout[self.kamp_state].min
    then
        return
    end
    local npc_id = npc:id()

    -- Если режиссер не закончил говорить - ждем конца фразы.
    if m_sound.sound_table[npc_id] then
        return
    end

    --printf("Proceed state for [%s]", npc_id)

    -- Определяются допустимые в данный момент переходы.
    local temp = {}
    local max_rnd = 0
    for k,v in pairs(self.trans_kamp[self.kamp_state]) do
        -- Определяются допустимые состояния для лагеря.
        if self.kamp_states[k] == true then
            temp[k] = v
            max_rnd = max_rnd + v
        end
    end
    -- Осуществляется рандомный взвешенный переход.
    if max_rnd == 0 then
        -- Если переходить некуда - переходим в айдл
        temp["idle"] = 100
        max_rnd = 100
    end
    local p = math.random(0,max_rnd)
    for k,v in pairs(temp) do
        p = p - v
        if p <= 0 then
            printf("Selected [%s]", k)
            if k == "idle" then
                self.director = nil
                if self.kamp_state ~= "idle" then
                    self.npc[npc_id].state_end = nil
                end
            else
                self.npc[npc_id].state_end = nil
                self.director = npc_id
                self.censor = nil
            end
            self.kamp_state = k
            self.begin = time_global()
            for kk,vv in pairs(self.npc) do
                vv.new = true
            end
            return
        end
    end
end
function CKampManager:proceedRole(npc_data, director)
    -- Определить список доступных анимаций по состоянию лагеря.
    -- определить список доступных анимаций по наличию предметов
    -- выбрать одну из них (то же самое со звуком).
    local state,states,sound = npc_data.state_selected
    if time_global() >= (npc_data.state_end or -1) then
        if director then
            states = self.avail_state[self.kamp_state].directed
            sound = self.avail_sound[self.kamp_state].directed
        else
            states = self.avail_state[self.kamp_state].undirected
            sound = self.avail_sound[self.kamp_state].undirected
        end
        -- Выбирать новое состояние только раз в какое то время.
        local temp = {}
        for k,v in pairs(states) do
            if npc_data.states[v] == true then
                table.insert(temp, v)
            end
        end
		if #temp == 0 then
			warning("proceedRole #temp == 0 director %s",director)
			table.print(npc_data)
		end
		state = temp[math.random(#temp)]
		npc_data.state_selected = state
        npc_data.state_end = time_global() + math.random(30000,90000)
    else
        if director then
            sound = self.avail_sound[self.kamp_state].directed
        else
            sound = self.avail_sound[self.kamp_state].undirected
        end
    end
    --printf("Proceed Role state [%s] sound [%s]", state, sound)
    return state, sound
end
function CKampManager:updateNpc(npc)
    local npc_id = npc:id()
	local npc_data = self.npc[npc_id]
    -- Проверка что сталкер может делать, а что нет.
    self:checkNpcAbility(npc,npc_data)
    -- Просим лагерь выбрать текущее состояние. Менять состояние лагеря
    -- имеет право только режиссер.
    local director = self.director == nil or self.director == npc_id
    if director then
        self:proceedState(npc)
    end
    -- Говорим чудаку выбрать себе состояние для текущего состояния лагеря.
    local state, sound = self:proceedRole(npc_data, director)

    local substate = nil
    if state == "wait_harmonica" then
        if sound == "pre_harmonica" and npc_data.new == true then
            m_sound.set_sound_play(npc, "intro_music")
            npc_data.new = false
        end
        state = "harmonica"
        kamp_stalkers[npc_id] = false
    elseif state == "play_harmonica" then
        state = "harmonica"
        substate = 1
        kamp_stalkers[npc_id] = false
    elseif state == "wait_guitar" then
        if sound == "pre_guitar" and npc_data.new == true then
            m_sound.set_sound_play(npc, "intro_music")
            npc_data.new = false
        end
        state = "guitar"
        kamp_stalkers[npc_id] = false
    elseif state == "play_guitar" then
        state = "guitar"
        substate = 1
        kamp_stalkers[npc_id] = false
    elseif state == "declarate" then
        if npc_data.new == true then
            if sound == "pre_joke" then
                m_sound.set_sound_play(npc, "intro_joke")
            elseif sound == "play_joke" then
                m_sound.set_sound_play(npc, "joke")
            end
            npc_data.new = false
        end

        if npc_data.comm == "monolith" then
            local t = math.mod(npc_id, 2)
            if t == 0 then
                state = "trans_0"
            else
                state = "trans_1"
            end
        elseif npc_data.comm == "zombied" then
            state = "trans_zombied"
        else
            local t = math.mod(npc_id, 3)
            if t == 0 then
                state = "sit"
            elseif t == 1 then
                state = "sit_ass"
            else
                state = "sit_knee"
            end
        end
        kamp_stalkers[npc_id] = false
    elseif state == "trans" then
        if npc_data.comm == "monolith" then
            local t = math.mod(npc_id, 2)
            if t == 0 then
                state = "trans_0"
            else
                state = "trans_1"
            end
        elseif npc_data.comm == "zombied" then
            state = "trans_zombied"
        end
        kamp_stalkers[npc_id] = false
    else
        kamp_stalkers[npc_id] = true
    end
    -- Выбор реальных звуков
    if sound == "idle" then
        sound = "state"
    elseif sound == "reac_guitar" then
        sound = "reac_music"
    elseif sound == "reac_harmonica" then
        sound = "reac_music"
    elseif sound == "reac_joke" then
        sound = nil
        if npc_data.new == true then
            if self.censor == nil then
                m_sound.set_sound_play(npc, "reac_joke")
                self.censor = npc_id
            else
                m_sound.set_sound_play(npc, "reac_laugh")
            end
            npc_data.new = false
        end
    else
        sound = nil
    end

    --printf("Proceed Update Npc [%s] sound [%s]", state, sound)
    return state, sound, substate
end
function CKampManager:checkNpcAbility(npc,npc_data)
    if npc_data.comm ~= "monolith" and npc_data.comm ~= "zombied" then
        -- есть колбасу
        if npc:object("kolbasa") then
            npc_data.states["eat_kolbasa"] = true
        else
            npc_data.states["eat_kolbasa"] = false
        end
        -- пить водку
        if npc:object("vodka") then
            npc_data.states["eat_vodka"] = true
        else
            npc_data.states["eat_vodka"] = false
        end
        -- пить енергитический напиток
        if npc:object("energy_drink") then
            npc_data.states["eat_energy"] = true
        else
            npc_data.states["eat_energy"] = false
        end
        -- есть хлеб
        if npc:object("bread") then
            npc_data.states["eat_bread"] = true
        else
            npc_data.states["eat_bread"] = false
        end
        -- играть на гармошке
        if self.population > 1 and npc:object("harmonica_a") then
            npc_data.states["play_harmonica"] = true
            npc_data.states["wait_harmonica"] = true
            self.kamp_states["pre_harmonica"] = true
            self.kamp_states["harmonica"] = true
            self.kamp_states["post_harmonica"] = true
        else
            npc_data.states["play_harmonica"] = false
            npc_data.states["wait_harmonica"] = false
            self.kamp_states["pre_harmonica"] = false
            self.kamp_states["harmonica"] = false
            self.kamp_states["post_harmonica"] = false
        end
        -- играть на гитаре
        if self.population > 1 and npc:object("guitar_a") then
            npc_data.states["play_guitar"] = true
            npc_data.states["wait_guitar"] = true
            self.kamp_states["pre_guitar"] = true
            self.kamp_states["guitar"] = true
            self.kamp_states["post_guitar"] = true
        else
            npc_data.states["play_guitar"] = false
            npc_data.states["wait_guitar"] = false
            self.kamp_states["pre_guitar"] = false
            self.kamp_states["guitar"] = false
            self.kamp_states["post_guitar"] = false
        end
        -- анекдоты
        if self.population > 1 then
            self.kamp_states["pre_joke"] = true
            self.kamp_states["joke"] = true
            self.kamp_states["post_joke"] = true
        else
            self.kamp_states["pre_joke"] = false
            self.kamp_states["joke"] = false
            self.kamp_states["post_joke"] = false
        end
    end
end
function CKampManager:addNpc(npc)
--    printf("KAMP [%s] add npc", npc:name())
    if self.npc[npc:id()] ~= nil then
        printf("NPC is already exist")
        return
    end

	local npc_data = {name = npc:name(), comm = npc:character_community(), position = nil}
    if npc_data.comm == "monolith" or npc_data.comm == "zombied" then
        npc_data.states = { declarate = true, trans = true}
    else
        npc_data.states = { sit = true, sit_ass = true, sit_knee = true, declarate = true,
            eat_kolbasa = false, eat_vodka = false, eat_energy = false, eat_bread = false, }	--play_harmonica = false, play_guitar = false, play_joke = false
    end
	self.npc[npc:id()] = npc_data
    self:selectPosition(npc:id())
end
function CKampManager:removeNpc(npc)
--    printf("KAMP [%s] remove npc", npc:name())
    local npc_id = npc:id()
    if self.npc[npc_id] ~= nil then
        self.position[self.npc[npc_id].position].used = nil
        self.npc[npc_id] = nil
        -- Если удаляем режиссера - необходимо форсированно перевести лагерь в идловое состояние.
        if self.director == npc_id then
            self.director = nil
            self.censor = nil
            self.kamp_state = "idle"
            self.begin = time_global()
            for kk,vv in pairs(self.npc) do
                vv.new = true
            end
            stop_play_sound(npc)
        end
    end
end
function CKampManager:increasePops(npc)
    self.population = self.population + 1
end
function CKampManager:decreasePops(npc)
    self.population = self.population - 1
end

----------------------------------------------------------------------------------------------------------------------
--Kamp janitor/анти-панихида
----------------------------------------------------------------------------------------------------------------------
local janitors = {} -- кто какой труп оттаскивает
local body_use_count = {} -- сколько попыток оттащить было сделано
local body_grab_bones = {
	[clsid.snork_s] = "bip01_spine2",
	[clsid.tushkano_s] = "bip01_head",
	[clsid.flesh_s] = "bip01_head",
	[clsid.boar_s] = "bip01_spine2",
	[clsid.gigant_s] = "bip01_l_calf",
	[clsid.chimera_s] = "bip01_l_calf",
	default = "bip01_spine1"
}

class "evaluator_see_deadman" (property_evaluator)
function evaluator_see_deadman:__init(name, storage) super (nil, name)
	self.a = storage
end
function evaluator_see_deadman:evaluate()
	local npc = self.object
	-- Есть дела поважнее, чем трупы складировать...
	if not xr_logic.is_active(npc, self.a) or npc:best_enemy() or npc:is_talking() then
		if self.a.choosed_deadman then
			janitors[self.a.choosed_deadman] = nil
			self.a.choosed_deadman = nil
			self.a.reached = nil
		end
		return false
	end

	-- Труп себе уже выбрали, не спускаем с него глаз...
	if self.a.choosed_deadman then
		local obj = level.object_by_id(self.a.choosed_deadman)
		if obj and obj:position():distance_to(patrol(self.a.center_point):point(0)) < 20 then
			return true
		end
		-- если утащен далеко, то ну его нафиг...
		janitors[self.a.choosed_deadman] = nil
		self.a.choosed_deadman = nil
		self.a.reached = nil
		return false
	end

	if (self.a.check_timer or 0) < time_global() then
		self.a.check_timer = time_global()+math.random(5000,10000)

		local center_pos = patrol(self.a.center_point):point(0)
		if npc:position():distance_to_sqr(center_pos) > 16*16 then
			return false
		end

		for o in npc:memory_visible_objects() do
			local obj = o:object()
			--если есть рядом с костром труп сталкера или монстра, его еще никто не прихватил себе и трупец нигде не застрял, то забираем его...
			if not obj:alive() and obj:is_entity_alive() then
				local obj_id = obj:id()
				local jan = janitors[obj_id] and level.object_by_id(janitors[obj_id])
				local init_dist = obj:position():distance_to_sqr(center_pos)+3
				if not (jan and jan:alive()) and init_dist < 12*12 then
					if (body_use_count[obj_id] or 0) < 10 and obj:center():distance_to_sqr(level.vertex_position(obj:level_vertex_id())) < 8 then	-- and npc:accessible(obj:level_vertex_id())
						body_use_count[obj_id] = (body_use_count[obj_id] or 0) +1
						-- ...заодно сразу прикидываем, куда бы его оттащить от костра, желательно под забор, стену дома и т.п.,
						-- за неимением таковых - будем тащить куда попало, главное - подальше от костра
						local max_dist = init_dist
						local tgt_vertex = nil
						local base_dir = obj:position():sub(center_pos)
						local base_point = obj:level_vertex_id()	--level.vertex_in_direction(obj:level_vertex_id(),vector():mul(base_dir,-1),17)
						for ang = -90,90,20 do
							local cur_vert = npc:vertex_in_direction(base_point,base_dir:rotate_y(ang),15)
							if cur_vert < INVALID_LEVEL_VERTEX_ID then
								local dist = level.vertex_position(cur_vert):distance_to_sqr(center_pos)
								if dist>11*11 and dist<16*16 then
									if dist > max_dist then
										max_dist = dist
										tgt_vertex = cur_vert
									end
								end
							end
						end
						if tgt_vertex == nil or not npc:accessible(tgt_vertex) then
							local v = level.vertex_in_direction(base_point,base_dir:rotate_y(math.random()*360),15)
							if level.vertex_position(v):distance_to_sqr(center_pos) > init_dist then
								tgt_vertex = v
							end
						end
						if tgt_vertex and npc:accessible(tgt_vertex) then
							janitors[obj_id] = npc:id()
							self.a.choosed_deadman = obj_id
							self.a.drop_lvid = tgt_vertex
							self.a.captures = 0
--							self.a.check_timer = time_global()+31000
							return true
						end
					end
				end
			end
		end
	end

	return false
end

--' Тащим труп
class "evaluator_can_move_deadman" (property_evaluator)
function evaluator_can_move_deadman:__init(name, storage) super (nil, name)
	self.a = storage
end
function evaluator_can_move_deadman:evaluate()
	if not self.a.reached then
		return false
	end
	local obj = level.object_by_id(self.a.choosed_deadman)
	--если труп застрял (расстояние увеличилось), то возвращаемся к нему
	return obj and obj:center():distance_to(self.object:position()) < 2.1
end

--Идет к бездыханному товарищу
class "action_go_to_deadman" (action_base)
function action_go_to_deadman:__init (name,storage) super (nil,name)
	self.a = storage
end
function action_go_to_deadman:initialize()
	action_base.initialize(self)
	local npc = self.object
	npc:set_desired_position()
	npc:set_desired_direction()
	npc:set_path_type(game_object.level_path)
	local gi = level.object_by_id(self.a.choosed_deadman)
	if gi then
		--попремся в сторону головы - за шкирятник тащить бум
		self.a.dest_lvid = gi:level_vertex_id()
		local bone = body_grab_bones[gi:clsid()] == "bip01_l_calf" and "bip01_l_calf" or "bip01_head"
		local diff = gi:bone_position(bone):sub(level.vertex_position(self.a.dest_lvid))	--(gi:position())
		local len = diff:magnitude()*1.4
		self.a.dest_lvid = npc:vertex_in_direction(self.a.dest_lvid,diff,len)
		if self.a.dest_lvid >= INVALID_LEVEL_VERTEX_ID or not npc:accessible(self.a.dest_lvid) then
			self.a.dest_lvid = npc:accessible_nearest(gi:bone_position(bone),vector())
		end
	else
		self.a.dest_lvid = npc:level_vertex_id()
	end
	self.target_id = self.a.choosed_deadman
	self.a.reached = false
	--пойдем не спеша...
	state_mgr.set_state(self.object, self.a.def_state_moving)
	--на все гулянки в сторону трупа дается 30 секунд, если не успел, то да ну нафиг заморачиваться :)
	self.a.go_time_end = time_global()+30000
	self.a.captures = self.a.captures + 1
end

function action_go_to_deadman:execute ()
	action_base.execute(self)
	if self.target_id ~= self.a.choosed_deadman then
		self:initialize()
		return
	end
	local npc = self.object
	local gi = level.object_by_id(self.a.choosed_deadman)
	-- если уже задолбало дергать труп, а он застрял (дергаем 3 раза), то нафиг его
	-- так же если какой то мимопроходящий товарищ труп с места сдвинул - то туда ему и дорога (трупу), а нам он больше не интересен
	if self.a.captures == 5 or self.a.go_time_end<time_global() or gi == nil then
		janitors[self.a.choosed_deadman] = nil
		self.a.choosed_deadman = nil
		self.a.reached = nil
		self.a.captures = nil
		self.a.check_timer = time_global()+math.random(20000,60000)
	else
		npc:set_dest_level_vertex_id(self.a.dest_lvid)
		-- долгое путешествие до трупа успешно завершилось, ура, товарищи
		local dist = npc:position():distance_to(gi:center())
		if self.a.dest_lvid == npc:level_vertex_id() and dist < 1.7 or dist < 1 then
			self.a.reached = true
			npc:set_dest_level_vertex_id(npc:level_vertex_id())
		elseif npc:path_completed() then
			janitors[self.a.choosed_deadman] = nil
			body_use_count[self.a.choosed_deadman] = body_use_count[self.a.choosed_deadman]+1
			self.a.choosed_deadman = nil
			self.a.reached = nil
			self.a.captures = nil
			self.a.check_timer = time_global()+4000
		end
	end
end

function action_go_to_deadman:finalize ()
	action_base.finalize(self)
end

--Тащит трупец
class "action_moving_deadman" (action_base)
function action_moving_deadman:__init (name,storage) super (nil,name)
	self.a = storage
end
function action_moving_deadman:initialize()
	action_base.initialize(self)
	local npc=self.object
	state_mgr.lock(npc,true)
	--если пушка в руках - прячем, а то тащить неудобно
	if npc:weapon_unstrapped() then
		npc:set_item(object.idle,nil)
	end
	--потащим медленно, осторожно и на карачках
	npc:set_movement_type(move.walk)
	npc:set_mental_state(anim.danger)
	npc:set_body_state(move.crouch)

	--на таскание трупа в грязи даем 30 секунд
	self.a.time_end = time_global()+30000
	self.force = vector():set(0,0,0)
	--на приседание рядом с трупом и разворот лицом дадим секунду
	self.time_drag = time_global()+1000
	local gi = level.object_by_id(self.a.choosed_deadman)
	local ps = gi and gi:get_physics_shell()
	if not ps then
		janitors[self.a.choosed_deadman] = nil
		self.a.choosed_deadman = nil
		self.a.reached = nil
		return
	end
	self.last_vid = npc:level_vertex_id()
	self.last_pos = npc:position()
	-- смотри мне в глаза!
	npc:set_sight(gi,false,false,true)
	-- нужно выбрать косточку для тяги
	self.bone = body_grab_bones[gi:clsid()] or body_grab_bones.default
	if not ps:get_element_by_bone_name(self.bone) then
		self.bone = nil
	end
	if not self.bone then
		janitors[self.a.choosed_deadman] = nil
		self.a.choosed_deadman = nil
		self.a.reached = nil
	end
end

function action_moving_deadman:execute ()
	action_base.execute (self)
	local npc = self.object

	if not self.a.choosed_deadman then
		return
	end

	--хватит таскать труп - время истекло, пусть другие этим занимаются
	if self.a.time_end<time_global() then
		janitors[self.a.choosed_deadman] = nil
		self.a.choosed_deadman = nil
		self.a.reached = nil
		self.a.check_timer = time_global()+math.random(20000,60000)
		return
	end

	if npc:level_vertex_id() ~= self.last_vid then
		local dir = self.last_pos:sub(npc:position())
		dir.y = 0
		npc:set_sight(look.direction,dir,true)
		self.last_vid = npc:level_vertex_id()
		self.last_pos = npc:position()
	end

	if not self.anim and self.time_drag - 700 < time_global() then
		self.anim = true
		npc:add_animation("cr_raciya_0_hide_1",true)
	end

	if self.time_drag > time_global() then
		return
	end

	npc:set_dest_level_vertex_id(self.a.drop_lvid)

	if not self.call then
		self.call = true
		npc:set_fastcall(self.move_body,self)
	end

	-- уф! дотащили... всем спасибо, все свободны...
	if self.a.drop_lvid and self.a.drop_lvid == npc:level_vertex_id() then
		janitors[self.a.choosed_deadman] = nil
		body_use_count[self.a.choosed_deadman] = body_use_count[self.a.choosed_deadman]+2
		self.a.choosed_deadman = nil
		self.a.reached = nil
	end
end
function action_moving_deadman:move_body()
	if not (self.call and self.a.choosed_deadman) then
		return true
	end
	local gi = level.object_by_id(self.a.choosed_deadman)
	local ps = gi and gi:get_physics_shell()
	if not ps then
		janitors[self.a.choosed_deadman] = nil
		self.a.choosed_deadman = nil
		self.a.reached = nil
		return true
	end
	-- непись сильный - тащит левой рукой за туловище трупа
	local el = ps:get_element_by_bone_name(self.bone)
	if not el then
		janitors[self.a.choosed_deadman] = nil
		self.a.choosed_deadman = nil
		self.a.reached = nil
		return true
	end
	local dir = self.object:bone_position("bip01_l_hand"):sub(gi:bone_position(self.bone))
	local d = vector():set(dir)
	d.y = 0
	d = (d:magnitude()+0.45)
	dir:mul(40*gi:mass())
	dir.y = (dir.y > 0 and dir.y or 0)+8*gi:mass()*d+50
	self.force:mul(0.5)
	dir:mul(0.5)
	self.force:add(dir)
	el:apply_force(self.force.x,self.force.y,self.force.z)
	return false
end

function action_moving_deadman:finalize ()
	action_base.finalize (self)
	state_mgr.lock(self.object,false)
	state_mgr.set_state(self.object, self.a.def_state_moving)
	self.anim = nil
	self.call = nil
	self.bone = nil
	self.last_vid = nil
	self.last_pos = nil
end

----------------------------------------------------------------------------------------------------------------------
--Kamp binder
----------------------------------------------------------------------------------------------------------------------
function add_to_binder(object, ini, scheme, section, storage)
    local operators = {}
    local properties = {}
	local move_body = object:character_community() ~= "zombied"

    local manager = object:motivation_action_manager()

    properties["kamp_end"]        = evaluators_id.stohe_kamp_base + 1
    properties["on_position"]    = evaluators_id.stohe_kamp_base + 2
    properties["contact"]        = evaluators_id.stohe_meet_base + 1

	properties["see_deadman"]	= evaluators_id.stohe_kamp_base + 3
	properties["can_move_deadman"]	= evaluators_id.stohe_kamp_base + 5
	properties["state_mgr_off"]	= evaluators_id.state_mgr + 3

    operators["go_position"]    = actions_id.stohe_kamp_base + 1
    operators["wait"]        = actions_id.stohe_kamp_base + 3

	operators["go_to_deadman"]		= actions_id.stohe_kamp_base + 4
	operators["move_deadman"]		= actions_id.stohe_kamp_base + 5

    -- Evaluators
    manager:add_evaluator (properties["kamp_end"],		this.evaluator_kamp_end		("kamp_end", storage, "kamp_end"))
    manager:add_evaluator (properties["on_position"],	this.evaluator_on_position	("kamp_on_position", storage, "kamp_on_position"))

	if move_body then
		manager:add_evaluator (properties["see_deadman"], this.evaluator_see_deadman ("see_deadman", storage))
		manager:add_evaluator (properties["can_move_deadman"], this.evaluator_can_move_deadman ("can_move_deadman", storage))
	end

    -- Actions
    local action = this.action_wait (object:name(),"action_kamp_wait", storage)
    action:add_precondition        (world_property(stalker_ids.property_alive, true))
    action:add_precondition        (world_property(stalker_ids.property_danger,false))
    action:add_precondition        (world_property(stalker_ids.property_enemy,    false))
    action:add_precondition        (world_property(stalker_ids.property_anomaly,false))
	if move_body then
		action:add_precondition    (world_property(properties["see_deadman"], 	false))
	end

    ai_common.add_common_precondition(action)
    action:add_precondition        (world_property(properties["on_position"],     true))
    action:add_effect         (world_property(properties["kamp_end"],     true))
    manager:add_action (operators["wait"], action)
    xr_logic.subscribe_action_for_events(object, storage, action)

    action = this.action_go_position (object:name(),"action_go_kamp", storage)
    action:add_precondition        (world_property(stalker_ids.property_alive, true))
    action:add_precondition        (world_property(stalker_ids.property_danger,false))
    action:add_precondition        (world_property(stalker_ids.property_enemy,    false))
    action:add_precondition        (world_property(stalker_ids.property_anomaly,false))
	if move_body then
		action:add_precondition    (world_property(properties["see_deadman"], 	false))
	end

    ai_common.add_common_precondition(action)
    action:add_precondition     (world_property(properties["on_position"],     false))
    action:add_effect         (world_property(properties["on_position"],     true))
    manager:add_action (operators["go_position"], action)

    action = manager:action (actions_id.alife)
    action:add_precondition        (world_property(properties["kamp_end"],        true))

	if move_body then
		-- видим труп - идем разбираться...
		action = this.action_go_to_deadman ("action_go_to_deadman", storage)
		action:add_precondition		(world_property(stalker_ids.property_alive, true))
		action:add_precondition		(world_property(stalker_ids.property_danger,false))
		action:add_precondition		(world_property(stalker_ids.property_enemy,	false))
		action:add_precondition		(world_property(stalker_ids.property_anomaly,false))
		action:add_precondition 	(world_property(properties["see_deadman"], 	true))
		action:add_precondition 	(world_property(properties["can_move_deadman"], 	false))
		action:add_precondition		(world_property(properties["kamp_end"],		false))
		ai_common.add_common_precondition(action)
		action:add_effect 			(world_property(properties["can_move_deadman"], 	true))
		manager:add_action(operators["go_to_deadman"], action)

		--тащим труп подальше от тусовки
		action = this.action_moving_deadman ("action_moving_deadman", storage)
		action:add_precondition		(world_property(stalker_ids.property_alive, true))
		action:add_precondition		(world_property(stalker_ids.property_danger,false))
		action:add_precondition		(world_property(stalker_ids.property_enemy,	false))
		action:add_precondition		(world_property(stalker_ids.property_anomaly,false))
		action:add_precondition 	(world_property(properties["see_deadman"], 	true))
		action:add_precondition 	(world_property(properties["can_move_deadman"], 	true))
		action:add_precondition 	(world_property(properties["state_mgr_off"], 	true))
		action:add_precondition		(world_property(properties["kamp_end"],		false))
		ai_common.add_common_precondition(action)
		action:add_effect 			(world_property(properties["see_deadman"], 	false))
		action:add_effect 			(world_property(properties["can_move_deadman"], 	false))
		manager:add_action(operators["move_deadman"], action)
	end
end
-- включение лагеря
function set_scheme(npc, ini, scheme, section, gulag_name)
    local st = xr_logic.assign_storage_and_bind(npc, ini, scheme, section)

    st.logic     = xr_logic.cfg_get_switch_conditions(ini, section, npc)

    st.center_point = cfg_get_string(ini, section, "center_point", npc, true,  gulag_name)
    st.radius        = cfg_get_number(ini, section, "radius", npc, false, 2)

    if kamps[st.center_point] == nil then
        kamps[st.center_point] = CKampManager(st.center_point)
    end
    kamps[st.center_point]:addNpc(npc)
    st.pos_vertex = nil

    st.def_state_moving = cfg_get_string(ini, section, "def_state_moving", npc, false, "", "walk")
end

function update_npc_ability(npc)
	local st = db.storage[npc:id()]
	if st.active_scheme == 'kamp' then
		kamps[st.kamp.center_point]:checkNpcAbility(npc)
	end
end