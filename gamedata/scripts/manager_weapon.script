--[[ ----------------------------------------------------------------------------------------------
 File       : manager_weapon.script
 Description: Менеджер оружия сталкеров
 Copyright  : 2017 © Prosectors Project
 Author(s)  : Rulix aka Bak
 Original   : AI Additions, 16.10.2016
--]] ----------------------------------------------------------------------------------------------
_DEBUG_ = true

function init()
	event("presets"):register(presets)
end

function presets()
	if wm_modes.enabled then
--		event("npc_1st_update"):register(npc_net_spawn)
		event("npc_spawn"):register(npc_net_spawn)
		event("npc_destroy"):register(npc_net_destroy)
		event("npc_death"):register(npc_death)
		event("activate_by_section"):register(reset_scheme)
--		event("actor_update"):register(global_update, {__period = 1032})
	end
	init_wm()
end

function printf(s,...)
--	log("wm:"..s,...)
end
local function printw(s,...)
	log("!wm:"..s,...)
end
local function sort_prm(a,b)
	return a.prm > b.prm
end

local weapon_params = {} -- параметры оружия будем хранить здесь
local ammo_params = {}
local update_time = time_global()
local wm_ini = ini_file([[misc\ai_additions\weapon_manager.ltx]])
assert(wm_ini:section_exist("main"),"no wm_ini")
local defsec = 'default'
local function gmode(wpn) local wgl = wpn:get_weapon_mwg() return wgl and wgl.grenade_mode or false end

wm_modes = {sect = {custom = {}, default = {}}, -- данные из конфигов
		koeffs = {},
		priors = {},
		types = {list = {},
				disd = {},
				disv = {},
				maxr = {},
				minr = {},
				enem = {},
				line = "ef_weapon_type"},
		forbiddens = {},
		enabled = read_from_ini(wm_ini,"main","enabled",false,0),
		update_prd = read_from_ini(wm_ini,"main","update_period",8290),
		combat_prd = read_from_ini(wm_ini,"main","combat_period",400),
		idle_prd = read_from_ini(wm_ini,"main","idle_period",20)*1000,
		min_cond = read_from_ini(wm_ini,"main","min_condition",0.2),
		wpn_minmax = read_from_ini(wm_ini,"main","weapon_minmaxr",true,0),
}

function init_wm() -- вычитывание конфига
	local ts,clslist = "types",creatures_clslist
	wm_modes.types.list = parse_list(wm_ini,ts,"list",false,true)
	for z,i in ipairs(wm_modes.types.list) do
		if wm_ini:line_exist(ts,"dist_"..i) then
			local dt,vt = {},{}
			local tmp = parse_list(wm_ini,ts,"dist_"..i)
			if #tmp < 2 then
				abort("weapon_manager: incorrect value dist_%s",i)
			end
--			table.sort(tmp,function(a,b) return tonumber(string.sub(a,1,string.find(a,":",1,true)-1)) < tonumber(string.sub(b,1,string.find(b,":",1,true)-1)) end)
			local m = 0
			for k,s in ipairs(tmp) do
				local p = string.find(s,":",1,true)
				local d,v = tonumber(string.sub(s,1,p-1)),tonumber(string.sub(s,p+1,-1))
				if not (d and v) then
					abort("weapon_manager: non-number in dist_%s",i)
				elseif d < m then
					abort("weapon_manager: incorrect order in dist_%s",i)
				end
				m = d
				table.insert(dt,d)
				table.insert(vt,v)
			end
			wm_modes.types.disd[i] = dt
			wm_modes.types.disv[i] = vt
		end
		if wm_ini:line_exist(ts,"minmaxr_"..i) then
			local tmp = parse_list(wm_ini,ts,"minmaxr_"..i,false,true)
			if #tmp ~= 2 then
				abort("weapon_manager: incorrect value minmaxr_%s",i)
			end
			wm_modes.types.minr[i] = tmp[1]
			wm_modes.types.maxr[i] = tmp[2]
		end
		local get_cls = function(str) for c,s in pairs(creatures_clslist) do if s == str then return c end end end
		if wm_ini:line_exist(ts,"enemy_"..i) then
			local t = {}
			local tmp = parse_list(wm_ini,ts,"enemy_"..i)
			for k,v in ipairs(tmp) do
				local p = string.find(v,":",1,true)
				if not p then
					abort("weapon_manager: incorrect value enemy_%s",i)
				end
				local cls = get_cls(string.sub(v,1,p-1))
				if not cls then
					abort("weapon_manager: not registered enemy class %s in enemy_%s",string.sub(v,1,p-1),i)
				end
				t[cls] = tonumber(string.sub(v,p+1,-1))
			end
			wm_modes.types.enem[i] = t
		end
	end
	wm_modes.forbiddens = parse_list(wm_ini,"main","forbidden_weapons",true)
	wm_modes.sect.default = read_mode_section(defsec)
end

class "weapon_manager"
function weapon_manager:__init(npc)
	self.npc = npc
	self.npc_id = npc:id()
	self.name = npc:name()	--npc:character_name()
	self.weapons = {}
	self.priors_mem = {}
	self.ammo_list = {}
	self:initialize()
end

function weapon_manager:initialize()
	local sect = self.npc:name()
	local dbst = db.storage[self.npc_id]
	if dbst and dbst.active_section then
		if dbst.ini:line_exist(dbst.active_section,"weapon_manager") then
			sect = dbst.ini:r_string(dbst.active_section,"weapon_manager")
		elseif dbst.ini:line_exist(dbst.section_logic,"weapon_manager") then
			sect = dbst.ini:r_string(dbst.section_logic,"weapon_manager")
		end
	end
	self.modes = read_wm_modes(self.npc:character_community(),m_ranks.get_obj_rank_name(self.npc),sect)
	if not wm_modes.enabled or self.modes.disabled == true or is_trader_mode(self.npc) then
		self.disabled = true
		printf(":initialize[%s]: disabled(trader %s)",self.name,is_trader_mode(self.npc))
		return
	end
	self.do_update_list = true
	self.do_update_weapon = true
	self.disabled_temp = -1
	self.process_spawn = true
--	printf("initialize[%s] comm[%s], rank[%s], name[%s], profile[%s]",self.name,self.npc:character_community(),m_ranks.get_obj_rank_name(self.npc),self.npc:name(),self.npc:profile_name())
end

function weapon_manager:update(tg)
--	logc("update[%s] act %s",self.npc:name(),debug_ai.stalker_action_name(self.npc:motivation_action_manager()))
	------------------ этап 1: если менеджер выключен, то не работаем
	if self.disabled then
--		self:set_weapon(nil)
		abort("[%s] update disabeld wm",self.name)
		return
	end
--	printf("[%s][%s]update %s == %s",self.name,tg,best_id,self.weapon_id)
	------------------ этап 2: обновление списка оружия
	if self.do_update_list then
--		if not self.npc:is_talking() then
			self:update_weapon_list()
--		end
	end
	if self.disabled_temp > tg then
		return
	end
	------------------ этап 4: проверка взрывоопасного оружия
	if self.blaster_weapon ~= nil and (self.blaster_timer or 0) < tg then		-- если имеется бластер и пора его проверять
		local allowed = false	-- проверяем возможность использования
		if self.modes.grenade_launcher_mode == 0 then
			allowed = can_use_blaster(self.npc,weapon_params[self.blaster_weapon.sec].bls or 9.9)
		elseif self.modes.grenade_launcher_mode > 0 then
			allowed = true
		end
		if allowed ~= self.blaster_allowed then									-- если статус изменился
			if allowed then														-- если можно
				table.insert(self.weapons,1,self.blaster_weapon)				-- добавляем в шапку табцицы
			else																-- иначе
				self:remove_weapon(self.blaster_weapon.id)						-- убираем
			end
			self.blaster_allowed = allowed										-- запоминаем статус
		end
		self.blaster_timer = tg + (allowed and 1500 or 8000)					-- 1.5 секунды при положительном ответе, 8 при отрицательном
	end
	------------------ этап 5: обновление активного оружия
	local cnt = #self.weapons
	if cnt == 0 then						-- если оружия нет - обновление не требуется
		if self.weapon_id then
			self:set_weapon(nil)			-- сбросим оружие, если осталось
		end
		return
	elseif not self.weapon_id then			-- если оружие не выбрано - обновляемся
--		printf("not self.weapon_id[%s]",self.name)
		self:update_weapon()
		return
	end
	if cnt == 1 then						-- если только одно оружие - обновление не требуется
		if self.weapon_id ~= self.weapons[1].id then
			printw("self.weapon_id == self.weapons[1].id (%s : %s)",self.weapon_id,self.weapons[1].id)
			self:update_weapon()
		end
		return
	end
	if self.do_update_weapon then			-- ещё что-то случилось, обновляемся
		printf("do_update_weapon[%s]",self.name)
		self:update_weapon()
		return
	end
	------------------ этап 6: проверка условий для обновления в бою
	local enemy = self.npc:best_enemy()
	if enemy and not (enemy:wounded() or self.npc:wounded()) then
		if self.last_wpn_update + wm_modes.combat_prd > tg then		-- время ещё не прошло
			return
		end
		local dist = self.npc:position():distance_to(enemy:position())
		local modes = self.modes
		if modes.combat_mode == 1 or modes.combat_mode == 3 then
			if self.last_change and modes.change_rest_time ~= 0 and self.npc:active_item() and self.last_change + modes.change_rest_time > time_global() then
				return												-- поменять оружие ещё нельзя, обновляться нет смысла
			end
			if enemy:id() ~= self.enemy_id then
				self:update_weapon(dist)							-- враг поменялся, обновляемся
				return
			end
			local dist_diff = dist > self.enemy_dist and dist-self.enemy_dist or self.enemy_dist-dist
			if dist_diff > 2+dist^0.5 then							-- расстояние значительно изменилось, обновляемся
				self:update_weapon(dist)
				return
			end
		elseif modes.combat_mode == 0 or modes.combat_mode == 2 then
			self.enemy_id = true
			if self.weapon_id ~= self.weapons[1].id and self.last_wpn_update + 16000 < tg then
				self:update_weapon(dist)							-- спустя время попытаемся вернуть лучшее оружие
				return
			end
			if weapon_params[self.weapon_section].dtn*self.ammos[self.weapon_section]._d < dist and self.weapons.dtn > dist then
				self:update_weapon(dist)							-- оружие не достаёт до врага, можно попытаться выбрать другое
				return
			end
		end
	end
	------------------ этап 7: обновление по идл таймеру
	if not enemy and self.enemy_id ~= nil then						-- сбрасываем память боевого режима
		self.last_change = nil
		self.enemy_id = nil
		self.enemy_dist = nil
		self.last_wpn_update = tg - math.random(wm_modes.idle_prd*0.75,wm_modes.idle_prd*0.95)	-- обновим оружие после боя
	end
	if self.last_wpn_update + wm_modes.idle_prd < tg then			-- обновляемся по таймеру
		self:update_weapon()
	end
end

function weapon_manager:on_weapon_empty(wpn,run_out)		-- если магазин пуст или оружие заклинило
	if run_out then		-- если вдруг кончились патроны - убираем
--		printf("[%s]run_out %s",self.name,wpn:name())
		self:remove_weapon(wpn:id(),true)
		return
	end
	self.do_update_weapon = true	-- возможно лучше сменить оружие вместо перезарядки
end

function weapon_manager:on_reload(wpn)
--	printf("on_reload[%s] wpn %s",self.name,wpn:name())
	self:update_ammo(wpn)		-- вызывается при каждой перезарядке
	if #self.weapons > 1 and math.random() <= 0.7 and npc_in_cover(self.npc) then	-- если я в перезаряжаюсь в укрытии
		local w = self.weapons[math.random(#self.weapons)]
		if w.id ~= self.weapon_id then
			local rwpn = level.object_by_id(w.id)
			if rwpn and rwpn:get_ammo_in_magazine() < weapon_params[w.sec].mag*0.7 then
				rwpn:set_ammo_elapsed(weapon_params[w.sec].mag)
			end
		end
	end
end

function weapon_manager:set_weapon(wpn)
	if wpn then
		local id = wpn:id()
		if id ~= self.weapon_id then
			self.weapon_id = id
			self.weapon_section = wpn:section()
		else
			return
		end
--		printf("[%s]set_weapon:set [%s]",self.name,wpn:name())
	elseif self.weapon_id == nil then
		return
	else
		printf("[%s]set_weapon:set nil",self.name)
		self.weapon_id = nil
		self.weapon_section = nil
	end
	self.npc:get_stalker().weapon_actuality = false
end

local function sort_dmg(a,b)
	return a.dmg > b.dmg or a.dmg == b.dmg and a.prm > b.prm
end
local function sort_dst(a,b)
	return a.dst > b.dst or a.dst == b.dst and a.dsp < b.dsp
end
local function sort_dsp(a,b)
	return a.dsp > b.dsp or a.dsp == b.dsp and a.prm > b.prm
end
function weapon_manager:update_ammo(wpn,cur_ammo)
	if self.modes.ammo_mode < 0 then
		return
	end
	if not wpn then
		return
	end
	-----------Этап 1: Проверим, есть ли из чего выбирать
	local wpn_sec = wpn:section()
	local ammos = self.ammos[wpn_sec]
	if not ammos or ammos._c then	-- если мы не знаем такого оружия, либо у нас только один тип патронов, или их вообще нет
--		printf("update_ammo[%s]:one or less ammo types",self.name)
		return
	end
	-----------Этап 2: Проверим необходимость обновления
	local enemy = self.npc:best_enemy()
--	if not (enemy or self.do_update_ammo) then	-- ?????
--		return	--??
--	end
--	self.do_update_ammo = false
	-----------Этап 3: Подготовка данных
	local cur_ammo = cur_ammo or wpn:get_type_ammo_in_magazine() -- on_reload arg2
	local aparams = read_ammo_params(cur_ammo)
	local wpn_dist = weapon_params[wpn_sec].dtn
	local cur_dist = wpn_dist*aparams.dst
	local aa = {}	-- теперь составим массивчик и отсортируем по требуемому параметру
	for a,p in pairs(ammos) do
		if a ~= "_d" then
			aa[#aa+1] = {sec = a, prm = p, dst = wpn_dist*ammo_params[a].dst, dsp = ammo_params[a].dsp, dmg = ammo_params[a].dmg}
		end
	end
	local enemy_dist = enemy and enemy:position():distance_to(self.npc:position())
	-----------Этап 4: Выбор патрона
	-- если расстояние до врага больше дальности стрельбы оружия с текущим боеприпасом - найдём патрон с большей дальностью
	-- TODO: если армированность врага больше бронеойности боеприпаса - найти более бронебойный
	-- если расстояние до врага больше 70 метров - найдём патрон с большей точностью
	-- если дистанция меньше 30 м - найдём патрон с большей мощностью
	-- иначе найдём лучший патрон
	local res,dr
	if not enemy_dist or self.modes.ammo_mode == 0 then
		table.sort(aa,sort_prm)
		dr = true
	elseif enemy_dist > cur_dist then
		table.sort(aa,sort_dst)
		dr = true
	elseif enemy_dist > 70 then
		table.sort(aa,sort_dsp)
	elseif enemy_dist < 30 then
		table.sort(aa,sort_dmg)
	else
		table.sort(aa,sort_prm)
	end
	res = aa[1]
	if not dr and res.dst < enemy_dist then
		table.sort(aa,sort_dst)
		res = aa[1]
	end
	-----------Этап 5: Задание типа боеприпаса
	local ctype = weapon_params[wpn_sec].ams[res.sec]-1
--	printf("update_ammo[%s]:set ammo type %s(%s)",self.name,ctype,res.sec)
	wpn:get_weapon().next_ammo_type = ctype
end

function weapon_manager:update_weapon(bedist)
	self.do_update_weapon = false
	self.last_wpn_update = time_global()+math.random(50)	-- для рассинхронизации
	local cnt = #self.weapons
	if cnt == 0 then
		self:set_weapon(nil)
		return
	elseif cnt == 1 then						-- имеется только одно оружие
		self:set_weapon(level.object_by_id(self.weapons[1].id))	--	его и ставим
		return
	end
	local modes = self.modes
	local be = self.npc:best_enemy()
	--------------------- врагов нет
	if not be then
		if modes.idle_mode == 0 then
			self:set_weapon(level.object_by_id(self.weapons[1].id))	-- просто выбираем оружие с наивысшим приоритетом
			return
		elseif modes.idle_mode == 1 then		-- выбираем лучшее наиболее приоритетного типа
			for k,t in ipairs(modes.types) do	-- перебор типов в порядке их приоритета
				for i=1,#self.weapons do
					local w = self.weapons[i]
					if w.typ == t then
						self:set_weapon(level.object_by_id(w.id))
						return
					end
				end
			end
		end
		abort("[%s]wm cant set weapon - incorrect idle mode %s",self.name,modes.idle_mode)
		return
	end
	---------------------------------
	local bedist = bedist or self.npc:position():distance_to(be:position())
	if modes.combat_mode == 0 then	-- статический режим
		self:set_weapon(self:pick_for_distance(bedist))				-- просто выбираем оружие с наивысшим приоритетом
		return
	elseif modes.combat_mode == 1 then								-- new mode
		self:set_weapon(self:pick_for_radius(bedist))
		self.enemy_dist = bedist
		self.enemy_id = be:id()
		return
	elseif modes.combat_mode == 2 then	-- включён режим последовательного перебора заряженного оружия
		local weapons = self:pick_for_distance(bedist,true)
		if self:check_conditions(0) then							-- если враг меня видит
			for i=1,#weapons do
				local wpn = level.object_by_id(weapons[i].id)
				if wpn:get_ammo_in_magazine() > 0 and not wpn:get_weapon().misfire then
					self:set_weapon(wpn)							-- выбираем первый заряженный ствол
					return
				end
			end
		end
		self:set_weapon(level.object_by_id(weapons[1].id))			-- иначе выбираем первый попавшийся
		return
	elseif modes.combat_mode == 3 then
	-------------------------------------------- Динамический режим
		local mprm = 0
		do
			local maxp = 0
			local slotr = modes.slot_restriction
			local pe = not slotr and self.weapons[1].sec == self.prefer_weapon
			for i=1,#self.weapons do
				local w = self.weapons[i]
				if slotr then
					w.prm = 130-i*30
				elseif pe then
					if w.sec == self.prefer_weapon then
						w.prm = w.prm/1000
					end
					maxp = w.prm > maxp and w.prm or maxp
				end
				mprm = mprm+w.prm
			end
			mprm = mprm/cnt
			if pe then
				self.weapons[1].prm = maxp*1.5		-- у предпочитаемого оружия параметр должен быть больше максимального на 50%
			end
		end
		local curwpn = level.object_by_id(self.weapon_id)
		local becls = be:clsid()
		local wpnp = {}
		for i=1,#self.weapons do					-- высчтитываем динамические модификаторы для каждого оружия
			local w = self.weapons[i]
			local pr,tpres = 0
			do	--bedist_to_pr
				local fr = weapon_params[w.sec].dtn*self.ammos[w.sec]._d
				if bedist >= fr then
					tpres = fr-bedist-60			-- учитывать превышение дистанции
				elseif modes.use_dist_preset then
					local dd = wm_modes.types.disd[w.typ]	-- or weapon_params[w.sec].disd
					local dv = wm_modes.types.disv[w.typ]	-- or weapon_params[w.sec].disv
					if not dd then
						printf(" cant find 'dist' (%s) for [%s]",w.typ,w.sec)
						tpres = 0
					else
						local i,pd,cd = 0
						repeat
							i,pd = i+1,cd
							cd = dd[i]
						until not cd or bedist < cd
						local pb = dv[i-1]
						tpres = not pb and dv[i] or not cd and pb or (bedist-pd)*(dv[i]-pb)/(cd-pd)+pb
					end
				else	-- если у нас есть один тип патронов, берём его, иначе берём тип из магазина
					local ammos,ammo_sec = self.ammos and self.ammos[w.sec]
					if ammos and ammos._c and ammos._c ~= true then
						ammo_sec = ammos._c
					else
						ammo_sec = level.object_by_id(w.id):get_type_ammo_in_magazine()	-- or weapon_params[w.sec].amt[1]
					end
					tpres = -(bedist*weapon_params[w.sec].dsp*ammo_params[ammo_sec].dsp)^0.5	--*(modes.priority_mode == 2 and wm_modes.koeffs[modes.koeffs].dsp or 1)
				end
			end
			pr = pr + mprm*tpres/100
			do	--becls_to_pr
				local enl = weapon_params[w.sec].enm or wm_modes.types.enem[w.typ]
				if enl then
					tpres = enl[becls] or 0
				else
					tpres = 0
				end
			end
			pr = pr + mprm*tpres/100
			if curwpn and self.weapon_id == w.id then
				if self:check_conditions(1) then
					pr = pr + w.prm*modes.active_add_fc/100
				else
					pr = pr + w.prm*modes.active_add/100
				end
			end
			local wpn = level.object_by_id(w.id)
			local amm1,amm2 = wpn:get_ammo_in_magazine(),weapon_params[w.sec].mag
			if amm1 == 0 or wpn:get_weapon().misfire then						-- магазин пуст, убавляем
				if self:check_conditions(3) then
					pr = pr - w.prm*modes.mag_lowering_fc/100
				else
					pr = pr - w.prm*modes.mag_lowering/100
				end
			else
				if amm1 ~= amm2 then
					pr = pr - w.prm*modes.mag_lowering/100*(amm2-amm1)^0.9/amm2
				end
				if curwpn and self.weapon_id == w.id and self.last_change then	-- проводим тормоз смены
					local tg = time_global()
					if self.last_change+modes.tchange_time_fc > tg and self:check_conditions(3) then
						local add = (self.last_change+modes.tchange_time_fc-tg)/40
						pr = pr + mprm*add/100
					elseif self.last_change+modes.tchange_time > tg then
						local add = (self.last_change+modes.tchange_time-tg)/50
						pr = pr + mprm*add/100
					end
				end
			end
			wpnp[#wpnp+1] = {id = w.id,prm = w.prm+pr}
		end
		table.sort(wpnp,sort_prm)
		if curwpn and wpnp[1].id ~= self.weapon_id then		-- and modes.change_rest_time ~= 0
			self.last_change = time_global()
		end
		self.enemy_dist = bedist
		self.enemy_id = be:id()
		self:set_weapon(level.object_by_id(wpnp[1].id))
		return
	end
	abort("[%s]wm cant set weapon - incorrect combat mode %s",self.name,modes.combat_mode)
end

function weapon_manager:check_conditions(nam)
	local tg = time_global()
	local be = self.npc:best_enemy()
	local me_see_be
	if self.last_me_see_be and self.last_me_see_be + 2000 > tg then
		me_see_be = true
	else
		me_see_be = self.npc:see(be)
		if me_see_be then
			self.last_me_see_be = tg
		else
			self.last_me_see_be = nil	--??
		end
	end
	local be_see_me
	if self.last_be_see_me and self.last_be_see_me + 1500 > tg then
		be_see_me = true
	else
		be_see_me = be:see(self.npc)
		if be_see_me then
			self.last_be_see_me = tg
		else
			self.last_be_see_me = nil	--??
		end
	end
	if nam == 0 and be_see_me then
		return true
	elseif nam == 1 and me_see_be and be_see_me then
		return true
	elseif nam == 2 and not (me_see_be or be_see_me) then
		return true
	elseif nam == 3 and be_see_me then
		if be:is_actor() then
			return true
		end
		local bebe = be:best_enemy() or be:get_enemy()
		if bebe and bebe:id() == self.npc_id then
			return true
		end
	end
	return false
end

function weapon_manager:update_weapon_list()
	self.do_update_list,self.blaster_allowed,self.blaster_weapon,self.process_spawn = false,false,nil,nil
	local __weapons,__full,__ammos,__bb = {dtn = 0},{},{},0
	local amod = self.modes.ammo_mode
	local function weapon_iterator(_,item)
		local cls = item:clsid()
		if item:is_weapon_magazined() then
			local id = item:id()
			local sec = item:section()
			__full[id] = item
			if wm_modes.forbiddens[sec] ~= true and item:condition() >= wm_modes.min_cond and self:have_ammo(item) and not gmode(item) then
--				logf("%s ammo_type_in_magazine %s",item:name(),item:get_type_ammo_in_magazine())
				read_ammo_params(item:get_type_ammo_in_magazine())	-- вычитываем параметры заряженного патрона
				if weapon_blaster_classes[cls] then
					if self.modes.grenade_launcher_mode >= 0 then
						local prm = self:get_weapon_prior(item)			-- без полноценного расчёта боеприпаса, оно тут и не нужно
						self.priors_mem[id] = nil
						if sec == self.prefer_weapon then
							prm = prm*1000
						end
						if prm > __bb then
							self.blaster_weapon = {sec = sec,id = id,obj = item,typ = weapon_params[sec].typ}
							__bb = prm
						end
					end
				else
					__weapons[#__weapons+1] = {sec = sec,id = id,obj = item,typ = weapon_params[sec].typ}
--					printf("weapon_iterator[%s]:add [%s]",self.npc:character_name(),sec)
				end
			end
		elseif item:is_ammo() then
			local sec = item:section()
			if not __ammos[sec] then
				if amod < 0 then
					__ammos[sec] = true
					read_ammo_params(sec)
				else
					__ammos[sec] = self.ammo_list[sec] or self:get_ammo_prior(sec)
				end
			end
--		elseif cls == clsid.wpn_knife_s then
--			__full[item:id()] = item
		end
	end
	self.npc:iterate_inventory(weapon_iterator)
	local cnt = #__weapons
	-------------------ammo section------------------- не нужно обновлять приоритет патрона, нужно брать его из предыдущего списка ( а если параметры сменятся?)
--	if not skip_ammo then
		local ammos,aparams = {},ammo_params
		for i=1, cnt+1 do	-- + для бластера тоже
			local w = __weapons[i] or self.blaster_weapon
			local sec = w and w.sec
			if sec and not ammos[sec] then	-- проблема?: при наличии более одного экземпляра оружия и отсутствии пачек патронов - для всех будет учитываться дальность из магазина первого попавшегося оружия
				local s,c,d,o = {},0,0
				local amt = weapon_params[sec].amt
				if amod < 0 then								-- если нельзя выбирать патрон
					c = 1
					o = w.obj:get_type_ammo_in_magazine()	-- если тип из магазина есть в сумке, или в сумке ничего нет - берём тип из магазина
					if not __ammos[o] then
						for ii=1, #amt do
							if __ammos[amt[ii]] then
								o = amt[ii]						-- берём первый имеющийся тип
								break
							end
						end
					end
					d = aparams[o].dst
				elseif amod == 0 then						-- в случае ammo_mode == 0 используем дальность патрона с большим приоритетом
					local p = 0
					for ii=1, #amt do										-- составляем список патронов для оружия
						local a = amt[ii]
						local prm = __ammos[a]
						if prm then
							s[a] = prm
							o = a
							c = c+1											-- считаем кол-во типов патронов для оружия
							if prm > p then
								d = aparams[a].dst							-- запоминаем коэффициент дальности лучшего патрона
								p = prm
							end
						end
					end
				else
					for ii=1, #amt do										-- составляем список патронов для оружия
						local a = amt[ii]
						if __ammos[a] then
							local dst = aparams[a].dst
							s[a] = __ammos[a]
							o = a
							c = c+1											-- считаем кол-во типов патронов для оружия
							d = dst > d and dst or d						-- запоминаем наибольший коэффициент дальности
						end
					end
				end
				s._c = c == 1 and o or c == 0 and true or nil			-- три состояния: true(если список пуст), ammo_section(если 1 элемент) и nil (если больше 1)
				s._d = c > 0 and d or aparams[w.obj:get_type_ammo_in_magazine()].dst	-- если нет пачек в сумке, идём за дальностью в магазин
				ammos[sec] = s
			end
		end
		self.ammo_list = __ammos
		self.ammos = ammos
--	end
	-------------------------------------------------
	if self.blaster_weapon then
		self.blaster_weapon.prm = self:get_weapon_prior(self.blaster_weapon.obj)
	end
	for i=1, cnt do
		local w = __weapons[i]
		w.prm = self:get_weapon_prior(w.obj)
		if w.sec == self.prefer_weapon then
			w.prm = w.prm*1000
		end
	end
	table.sort(__weapons,sort_prm)								-- сортируем элементы по приоритету
	if cnt > 1 and self.modes.slot_restriction then				-- выбираем оружие для слотов
		local wbst,slot1,slot2 = {dtn = 0}
		for i=1,#__weapons do
			local w = __weapons[i]
			local slot = w.obj:get_slot()
			if slot1 and slot2 then
				break
			elseif not slot1 and slot == 1  then
				slot1 = true
				wbst[#wbst+1] = w
			elseif not slot2 and slot == 2  then
				slot2 = true
				wbst[#wbst+1] = w
			end
		end
--		printf("update_weapon_list[%s]:slots:[%s] [%s]",self.npc:character_name(),tostring(wbst[1] and wbst[1].sec),tostring(wbst[2] and wbst[2].sec))
		cnt = #wbst
		__weapons = wbst
	elseif cnt > 2 then
		if not self.modes.use_ident_weapons then					-- выносим дублирующееся оружие
			local exist_sections,rt,rc = {},{},0
			for i=1,#__weapons do
				local sec = __weapons[i].sec
				if not exist_sections[sec] then
					exist_sections[sec] = true				-- запоминаем секции
				else
					rt[#rt+1] = i							-- при совпадении секции запоминаем для последующего удаления
				end
			end
			if #rt ~= 0 then
				for i=1,#rt do
					table.remove(__weapons,rt[i]+rc)		-- удаляем, учитывая смещение индексов
					rc = rc-1								-- такой способ быстрее копирования таблиц
				end
				cnt = cnt-#rt
			end
		end
		local mw = self.modes.max_weapons_per_type
		if mw ~= 0 and cnt > mw then								-- выносим лишнее оружие по типам
			local tcnt,remt = {},{}
			for i=1,#__weapons do
				local typ = __weapons[i].typ
				tcnt[typ] = (tcnt[typ] or 0)+1				-- считаем количество по типам
				if tcnt[typ] > mw then
					remt[#remt+1] = i						-- лишнее заносим в таблицу на удаление
				end
			end
			if #remt ~= 0 then
				table.sort(remt,function(a,b) return a > b end)
				for i=1,#remt do
					table.remove(__weapons,remt[i])			-- удаляем с конца массива
				end
				cnt = cnt-#remt
			end
		end
		mw = self.modes.max_weapons
		if mw ~= 0 and cnt > mw then								-- выносим лишнее оружие по общему числу
--			printf("update_weapon_list[%s]:cut all [%s], remove %s",self.npc:character_name(),cnt,cnt-mw)
			for i = mw+1,cnt do
				table.remove(__weapons,mw+1)				-- удаляем всё лишнее
			end
			cnt = mw
		end
	end
	printf("update_weapon_list[%s]:cnt:[%s],wcnt:[%s],prm:[%s],wprm:[%s]",self.name,cnt,#self.weapons,cnt>0 and __weapons[1].prm,#self.weapons>0 and self.weapons[1].prm)
	if cnt ~= 0 and #self.weapons ~= 0 and __weapons[1].prm > self.weapons[1].prm+1 then
		self.do_update_weapon = true								-- если найдено оружие лучше прежнего - нужно обновить
	end
	local curpr = self.weapon_id == nil or self.blaster_weapon and self.blaster_weapon.id == self.weapon_id
	for i=1,#__weapons do
		local sec = __weapons[i].sec
		local dtn = weapon_params[sec].dtn*self.ammos[sec]._d
		__weapons.dtn = __weapons.dtn < dtn and dtn or __weapons.dtn	-- запоминаем наибольшее расстояние огня
		if not curpr and __weapons[i].id == self.weapon_id then
			curpr = true
		end
		__weapons[i].obj = nil	-- на самом деле должно быть безопасно, но пока переделывать желания нет
	end
	if not curpr then
		self.weapon_id = nil											-- если в новом списке нет выбранного оружия - нужно обновить
	end
	self.weapons = __weapons
end

function weapon_manager:get_full_weapon_list()	-- для rx_addons
	local wpn_list = {}
	local function weapon_iterator(_,item)
		local sec = item:section()
		if item:is_weapon_magazined() and wm_modes.forbiddens[sec] ~= true then
			local prm = self:get_weapon_prior(item)
			wpn_list[#wpn_list+1] = {sec = sec,id = item:id(),prm = prm,typ = weapon_params[sec].typ}
		end
	end
	self.npc:iterate_inventory(weapon_iterator)
--	table.sort(wpn_list,sort_prm)	-- сортируем - не нужно
--	printf("get_full_weapon_list[%s]:cnt:[%s]", self.name,#wpn_list)
	return wpn_list
end

function weapon_manager:pick_for_radius(dist)
	local weapons = self.weapons
	if not weapons or #weapons == 0 then
		return
	elseif #weapons == 1 then
		return level.object_by_id(weapons[1].id)
	end
	local min_diff,best_of_rest = 1000,1
	local params = weapon_params
	for i=1,#weapons do
		local w = weapons[i]
		local maxr = params[w.sec].mxr+3
		local minr = params[w.sec].mnr-1
		if dist < minr then
			if min_diff > minr-dist then
				min_diff = minr-dist
				best_of_rest = i
			end
		elseif dist > maxr then
			if min_diff > dist-maxr then
				min_diff = dist-maxr
				best_of_rest = i
			end
		else
			return level.object_by_id(w.id)
		end
	end
	return level.object_by_id(weapons[best_of_rest].id)
end

function weapon_manager:pick_for_distance(dist,list_please)
	local weapons,ammos = self.weapons,self.ammos
	if not weapons or #weapons == 0 then
		return
	elseif #weapons == 1 then
		return list_please and weapons or level.object_by_id(weapons[1].id)
	end
	local dist,parr = dist+5,{}
	local best_dist,best_by_dist = 0,1
	local params = weapon_params
	for i=1,#weapons do
		local w = weapons[i]
		local wdist = params[w.sec].dtn*ammos[w.sec]._d
		if wdist > dist then
			if list_please then
				parr[#parr+1] = w
			else
				return level.object_by_id(w.id)
			end
		end
		if best_dist < wdist then
			best_dist = wdist
			best_by_dist = i
		end
	end
	if not list_please then
		return level.object_by_id(weapons[best_by_dist].id)
	elseif #parr == 0 then
		return {weapons[best_by_dist]}
	else
		return parr
	end
end

function weapon_manager:get_weapon_prior(wpn,addonf)
	local id = wpn:id()
	if self.priors_mem[id] and not addonf then
		return self.priors_mem[id]
	end
	local sec = wpn:section()
	local params = weapon_params[sec] or read_wpn_params(sec)
	---------------------------ammo section
	local ammos,ammo_sec = self.ammos and self.ammos[sec]
	if #params.amt == 1 then		-- имеется один единственный тип патронов
		ammo_sec = params.amt[1]
	elseif ammos and ammos._c ~= true then		-- если есть список патронов - выбираем лучший тип
		if ammos._c then						-- у нас только один тип патронов
			ammo_sec = ammos._c
		else									-- нужно выбрать из нескольких лучший
			local bp,ba = -100000
			for a,p in pairs(ammos) do
				if a ~= "_d" and p > bp then
					bp,ba = p,a
				end
			end
			ammo_sec = ba
		end
	else							-- если списка нет - получаем тип патронов в магазине, если и там пусто, то берём первый
		ammo_sec = wpn:get_ammo_in_magazine() ~= 0 and wpn:get_type_ammo_in_magazine() or params.amt[1]
	end
	local aparams = read_ammo_params(ammo_sec)	--{dmg = k_hit,dsp = k_disp,dst = k_dist,bls = blast}
	if aparams.bls then
		params.bls = aparams.bls
		params.dmg = aparams.dmg
	elseif params.bls then
		aparams.dst = 1
		aparams.dsp = 0.5
	end
	----------------------------------------------
	local prm,pr,modes = 1,0,self.modes
	if modes.priority_mode == 1 then
		prm = params.cst+aparams.cst/3+modes.addcost
	elseif modes.priority_mode == 2 then
		local kf = wm_modes.koeffs[modes.koeffs]
		if params.bls then		-- для гранатомётов нам не важен разброс, и дальность не ограничена
			prm = (params.dmg*kf.dmg) + (params.rpm*kf.rpm) + (50*kf.dst) + (50*kf.dsp)
--			printf("get_weapon_prior[%s][%s](blaster):dmg = %s, rpm = %s, dst = %s, dsp = %s, result = %s",sec,ammo_sec,(params.dmg*kf.dmg),(params.rpm*kf.rpm),(50*kf.dst),(50*kf.dsp),prm)
		else
			prm = (params.dmg*aparams.dmg)*kf.dmg + (params.rpm*kf.rpm) + (params.dst*aparams.dst*kf.dst) + ((100/(params.dsp*aparams.dsp))*kf.dsp)
--			printf("get_weapon_prior[%s][%s]:dmg = %s, rpm = %s, dst = %s, dsp = %s, result = %s",sec,ammo_sec,(params.dmg*aparams.dmg)*kf.dmg,(params.rpm*kf.rpm),(params.dst*aparams.dst*kf.dst),((100/(params.dsp*aparams.dsp))*kf.dsp),prm)
		end
	elseif modes.priority_mode == 3 then
		prm = (wm_modes.priors[modes.priors][sec] or 0) + (wm_modes.priors[modes.priors][ammo_sec] or 0)
	end
--	printf("get_weapon_prior[%s][%s]:result = %s",sec,ammo_sec,prm)
	local af = get_addon_flag(wpn,true)+(addonf and addonf-get_addon_flag(wpn) or 0)
	if modes.scope ~= 0 and addon_attached(wpn,"sc",af) then
		pr = pr + prm*modes.scope/100
	end
	if modes.silencer ~= 0 and addon_attached(wpn,"sl",af) then
		pr = pr + prm*modes.silencer/100
	end
	if modes.grenadelauncher ~= 0 and addon_attached(wpn,"gl",af) then
		pr = pr + prm*modes.grenadelauncher/100
	end
	for k,v in ipairs(modes.types) do
		if v.t == params.typ then
			pr = pr + prm*v.p/100
			break
		end
	end
--	printf("get_weapon_prior[%s][%s]: result = %s (%s+%s) cond %s",self.name,sec,prm+pr+id/500000+wpn:condition()*prm/5,prm,pr,wpn:condition())
	prm = prm+pr+id/500000+wpn:condition()*prm*0.2
	if not addonf then
		self.priors_mem[id] = prm
	end
	return prm
end

function weapon_manager:get_ammo_prior(sec)
	local prm,modes = 1,self.modes
	local aparams = read_ammo_params(sec)	--{dmg = k_hit,dsp = k_disp,dst = k_dist,bls = blast}
	if modes.priority_mode == 1 then
		prm = aparams.cst
	elseif modes.priority_mode == 2 then
		local kf = wm_modes.koeffs[modes.koeffs]
		prm = aparams.dmg*kf.dmg + (2/aparams.dsp)*kf.dsp + aparams.ap*0.5
	elseif modes.priority_mode == 3 then
		prm = wm_modes.priors[modes.priors][sec] or 1
	end
--	printf("get_ammo_prior[%s]:result = %s",sec,prm)
	return prm
end

function weapon_manager:have_ammo(wpn,not_mine)
	local params = weapon_params[wpn:section()] or read_wpn_params(wpn:section())	-- обязательно вычитываем параметры
	if params.mag == 0 then
		return true
	elseif not not_mine then
		return wpn:get_ammo_total() ~= 0
	end
	for i=1,#params.amt do
		if self.npc:object(params.amt[i]) then
			return true
		end
	end
	return false
end

-- При приобретении оружия или патронов необходимо обновить список оружия
-- Однако лишний раз обновлять список нежелательно, поэтому хорошо бы проверить актуальность предмета
function weapon_manager:on_item_take(item)
	if self.process_spawn then
		return
	end
	if item:is_weapon_magazined() then	-- подобрал оружие
		printf("[%s] take weapon %s",self.name,item:name())
		if self:have_ammo(item) then	-- wm_modes.forbiddens[item:section()] ~= true and item:condition() >= wm_modes.min_cond and
			self.do_update_list = true							-- обновляем список
		end
	elseif item:is_ammo() then			-- подобрал патроны
--		printf("[%s] take ammo %s",self.name,item:name())
		if not self.ammo_list[item:section()] then				-- если такие уже есть, обновлять не нужно
			self.do_update_list = true							-- иначе обновляем список оружия
--			self.do_update_ammo = true							-- и патрон
			self.priors_mem = {}
		end
	end
end

-- При потере оружия нужно удалить его из списка. При потере патронов нужно обновить список оружия
function weapon_manager:on_item_drop(item)
	if item:is_weapon_magazined() then			-- потерал оружие
--		printw("[%s] drop weapon %s",self.name,item:name())
		local id = item:id()
		self:remove_weapon(id,true)
	elseif item:is_ammo() then		-- потерял патроны
--		printf("[%s] drop ammo %s",self.name,item:name())
		if not self.npc:object(item:section()) then				-- если больше таких нет
			self.do_update_list = true							-- обновим список
			self.priors_mem = {}
		end
	end
end

function weapon_manager:remove_weapon(id,full)
	local weapons = self.weapons
	for i=1,#weapons do
		if weapons[i].id == id then
			table.remove(weapons,i)	-- убираем из списка
			break
		end
	end
	if id == self.weapon_id then				-- если это активное оружие
--		printf("remove_weapon[%s]: dropt current weapon",self.npc:character_name())
		self.weapon_id = nil					-- нужно срочно обновлять
--[[		if #weapons ~= 0 then
			if update then
				self:update_weapon()				-- можно обновить прямо отсюда
			end
		end]]
	end
	if full then
		if self.blaster_weapon ~= nil and self.blaster_weapon.id == id then
			self.blaster_weapon = nil
			self.blaster_timer = nil
		end
		self.priors_mem[id] = nil
	end
end

----- events
function global_update()
end

function npc_net_spawn(a)
	if not a.is_stalker then
		return
	end
	local st = a.st.ai
	assert(st.wm == nil,"[%s] %s",a.obj:name(),st.wm~=nil)
	st.wm = weapon_manager(a.obj)
	if not st.wm.disabled then
		a.obj:get_stalker():set_wm(st.wm)
	end
end

function npc_update(a)	-- на первом апдейте создание менеджера, обновление со второго апдейта
	local st = a.st.ai
	if st.wm then
--		logc("npc_update %s time(%s)",a.obj:name(),time_global())
--		st.wm:update()
	else
		local se_npc = alife():object(a.obj_id)
		if se_npc and se_npc.online then
			st.wm = weapon_manager(a.obj)
			if not st.wm.disabled then
				a.obj:get_stalker():set_wm(st.wm)
			end
		else
			printf("%s update, npc offline!!! se_obj(%s) dbst(%s)",a.obj,se_npc,db.storage[a.obj_id])
		end
	end
end

function npc_death(a)
	kill_wm(a.obj_id,a.st)
end

function npc_net_destroy(a)
	if a.is_alive and not level.in_process_destroy() then
		kill_wm(a.obj_id,a.st)
	end
end

function kill_wm(id,st)
	st = st.ai
	if st and st.wm then
--		printf("kill_wm %s",id)
		st.wm:disable(nil,true)
		st.wm = nil
	end
end

----- Раздел чтения конфигов

local function read_priors_section(cm,section)
	if not cm then
		return
	end
	if cm.priority_mode == 2 and not wm_modes.koeffs[cm.koeffs] then
		if not wm_ini:section_exist(cm.koeffs) then
			abort("!weapon_manager: can`t find koeffs section [%s]",cm.koeffs)
		end
		local kf = {}
		kf.dmg = wm_ini:r_float(cm.koeffs,"damage")
		kf.rpm = wm_ini:r_float(cm.koeffs,"rpm")
		kf.dst = wm_ini:r_float(cm.koeffs,"distance")
		kf.dsp = wm_ini:r_float(cm.koeffs,"dispersion")
		wm_modes.koeffs[cm.koeffs] = kf
	elseif cm.priority_mode == 3 and not wm_modes.priors[cm.priors] then	-- wm_modes.sect.default.priors
		if not wm_ini:section_exist(cm.priors) then
			abort("!weapon_manager: can`t find priors section [%s]",cm.priors)
		end
		local pst = {cm.priors}
		if section ~= defsec then	-- ищем инклуды
			while pst[1] ~= wm_modes.sect.default.priors and wm_ini:section_exist(pst[1]) and wm_ini:line_exist(pst[1],"_include") do
				table.insert(pst,1,wm_ini:r_string(pst[1],"_include"))
			end
		end
		for i=1,#pst do				-- вычитываем все включённые секции
			local psec = pst[i]
			if not wm_modes.priors[psec] then
				local res = collect_sections(wm_ini,{psec},true)
				if section ~= defsec and res._include then
					setmetatable(res,{__index = wm_modes.priors[res._include]})
				end
				res._include = nil
				wm_modes.priors[psec] = res
			end
		end
	end
end

-- Здесь вычитываются кастомные секции - имя объекта или указанная в логике
local function read_custom_sect(sect,mt)
	local modes = wm_modes.sect.custom
	local ct = modes[sect]
	if not ct then
		ct = read_mode_section(sect)
		modes[sect] = ct
		read_priors_section(ct,sect)
--		table.print(ct,sect)
	end
	-- скопировать
	local res = {}
	for k,v in pairs(ct) do
		res[k] = v
	end
	setmetatable(res,{__index = mt})
	return res
end
-- Здесь вычитываются индивидуальные и групповые настройки режимов
-- Порядок приоритета такой: custom(name),community_rank,community,rank,default
-- Отсутствующие значения наследуются
function read_wm_modes(comm,rank,sect)
	local modes = wm_modes.sect
	--1 Есть ли у нас нестандартные настройки?
	local ex_rank = wm_ini:section_exist(rank) and wm_ini:line_count(rank) > 0
	local ex_comm = wm_ini:section_exist(comm) and wm_ini:line_count(comm) > 0
	local ex_commrank = wm_ini:section_exist(comm.."_"..rank) and wm_ini:line_count(comm.."_"..rank) > 0
	local ex_sect = wm_ini:section_exist(sect) and wm_ini:line_count(sect) > 0
	if not (ex_rank or ex_comm or ex_commrank or ex_sect) then
		return modes.default
	end
	--2 Вычитаны ли наши нестандартные настройки?
	if ex_commrank then
		if modes[comm..rank] then
			return ex_sect and read_custom_sect(sect,modes[comm..rank]) or modes[comm..rank]
		end
	elseif ex_comm then
		if modes[comm] then
			return ex_sect and read_custom_sect(sect,modes[comm]) or modes[comm]
		end
	elseif ex_rank then
		if modes[rank] then
			return ex_sect and read_custom_sect(sect,modes[rank]) or modes[rank]
		end
	elseif ex_sect then
		return read_custom_sect(sect,modes.default)
	end
	--3 Вычитываем наши нестандартные настройки
	local res
	if not modes[rank] and ex_rank then
		res = read_mode_section(rank)
		setmetatable(res,{__index = modes.default})
		modes[rank] = res
	end
	read_priors_section(res,rank)
	if not modes[comm] and ex_comm then
		res = read_mode_section(comm)
		setmetatable(res,{__index = modes.default})
		modes[comm] = res
	end
	read_priors_section(res,comm)
	if not modes[comm..rank] and ex_commrank then
		res = read_mode_section(comm.."_"..rank)
		if ex_comm and ex_rank then
			for k,v in pairs(modes[comm]) do
				if not res[k] then
					res[k] = v
				end
			end
		end
		setmetatable(res,{__index = ex_rank and modes[rank] or ex_comm and modes[comm] or modes.default})
		modes[comm..rank] = res
	end
	read_priors_section(res,comm.."_"..rank)
	return ex_sect and read_custom_sect(sect,res) or res
end

-- Функция парсинга секций настроек режимов
function read_mode_section(section)
	local cm = collect_sections(wm_ini,{section},true)
	--BOOL
	cm.disabled = nil or cm.disabled and wm_ini:r_bool(section,"disabled")
	cm.use_ident_weapons = nil or cm.use_ident_weapons and wm_ini:r_bool(section,"use_ident_weapons")
	cm.slot_restriction = nil or cm.slot_restriction and wm_ini:r_bool(section,"slot_restriction")
	--PRIORS
	if section == defsec then
		read_priors_section(cm,section)
	end
	--TYPES
	if cm.types then
		local tps = str_explode(",",cm.types)
		if #tps ~= #wm_modes.types.list then
			abort("!weapon_manager: incorrect announce [%s] types = %s",sect,cm.types)
		end
		cm.types = {}
		for k,v in ipairs(wm_modes.types.list) do
			table.insert(cm.types,{t = v,p = tonumber(tps[k])})
		end
		table.sort(cm.types,function(a,b) return a.p > b.p end)
	end
	return cm
end

local function read_if_exist_float(sec,val,def)
	return read_from_ini(nil,sec,val,def)
end

local function read_if_exist_integer(sec,val,def)
	return read_from_ini(nil,sec,val,def,3)
end

local function read_if_exist_string(sec,val,def)
	return read_from_ini(nil,sec,val,def,1)
end

function read_wpn_params(sect)
	if weapon_params[sect] == nil then
		assert(sect,"!weapon_manager: read_wpn_params no sect '%s'",sect)
		local typ = read_if_exist_integer(sect,wm_modes.types.line,-1)
		local c,t,k = true,false
		while(typ ~= t and t ~= nil) do
			k,t = next(wm_modes.types.list,k)
			c = typ ~= t
		end
		if c then
			printw("!weapon_manager: not registered weapon type '%s' in [%s]",typ,sect)
		end
--		assert(not c,"!weapon_manager: not registered weapon type '%s' in [%s]",typ,sect)
		local ammos,ammot = parse_list(nil,sect,"ammo_class",-1)
		local dmg, blast = get_dmg(sect)
		local rpm = get_rpm(sect)
		local disp = get_disp(sect)
		local dist, distr = get_dist(sect)
		local cost = read_if_exist_integer(sect,"cost",499)
		local magsize = read_if_exist_integer(sect,"ammo_mag_size",1)
		local minr = wm_modes.wpn_minmax and read_if_exist_float(sect,"min_radius",0) or wm_modes.types.minr[typ]
		local maxr = wm_modes.wpn_minmax and read_if_exist_float(sect,"max_radius",200) or wm_modes.types.maxr[typ]
		local enemyt = get_enemyt(sect)
		local rsec = nil	--get_rsect(sect)
--		local inupc = #parse_list(nil,sect,"installed_upgrades")
		weapon_params[sect] = {cst = cost,typ = typ,dmg = dmg,rpm = rpm,dsp = disp,dst = dist,dtn = distr,mag = magsize,mnr = minr,mxr = maxr,ams = ammos,amt = ammot,enm = enemyt,rsc = rsec,bls = blast,iuc = inupc}
	end
	return weapon_params[sect]
end

function get_dmg(section,ammo_list)
	local ltx = system_ini()
	if ltx:line_exist(section,"rocket_class") then
		local grenade =  ltx:r_string(section,"rocket_class")
		return get_rocket_dmg(grenade)
	end
	local hit_power = read_if_exist_float(section,"hit_power",0.5)
	return (hit_power*40)^0.9
end

function get_rpm(section)
	local mag_size = read_if_exist_integer(section,"ammo_mag_size",2)
	if mag_size < 4 then
		return (mag_size^0.4)*5
	end
	local rpm = read_if_exist_float(section,"rpm",10)
	rpm = ((rpm/2)^0.2)*8
	local f_modes = read_if_exist_string(section,"fire_modes","1")
	if string.find(f_modes,"-1") or (tonumber(f_modes) and tonumber(f_modes) > 4) then
		rpm = rpm*1.3
	end
	return rpm+(mag_size/3)
end

function get_disp(section)
	local disp_base	= math.max(0.2,read_if_exist_float(section,"fire_dispersion_base",0.5))
	return disp_base*10
end

function get_dist(section)
	local dist = math.min(200,read_if_exist_float(section,"fire_distance",50))
	return (dist/2)^0.7,dist
end

function read_ammo_params(sect)
	if ammo_params[sect] == nil then
		local cost = read_if_exist_integer(sect,"cost",310)
		local k_hit,blast = get_ammo_dmg(sect)
		local k_disp = blast and 0.5 or get_ammo_disp(sect)	-- просто умножение на коэффициент
		local k_dist = blast and 1 or read_if_exist_float(sect,"k_dist",1)		-- просто умножение на коэффициент
		local k_ap = blast and 0.5 or read_if_exist_float(sect,"k_ap",0)
--		printf("read_ammo_params[%s]:cost %s, k_hit %s, k_dist %s, k_disp %s blast %s",sect,cost,k_hit,k_dist,k_disp,tostring(blast))
		ammo_params[sect] = {cst = cost,dmg = k_hit,ap = k_ap,dsp = k_disp,dst = k_dist,bls = blast}
	end
	return ammo_params[sect]
end

function get_ammo_dmg(section)
	local ltx = system_ini()
	if ltx:line_exist(section,"fake_grenade_name") then
		local grenade = ltx:r_string(section,"fake_grenade_name")
		return get_rocket_dmg(grenade)
	end
	local k_hit = read_if_exist_float(section,"k_hit",1)
	local buck = read_if_exist_integer(section,"buck_shot",1)
	return k_hit*buck^0.5
end

function get_ammo_disp(section)
	local k_disp = read_if_exist_float(section,"k_disp",1)
	local buck = read_if_exist_integer(section,"buck_shot",1)
	k_disp = k_disp*buck^-0.5		-- дробь также немного увеличивает точность
	return k_disp
end

function get_rocket_dmg(section)
	local blast = read_if_exist_float(section,"blast",2)
	local blast_r = read_if_exist_float(section,"blast_r",3)
	local frags = read_if_exist_integer(section,"frags",5)
	local frag_hit = read_if_exist_float(section,"frag_hit",1)
	local frags_r = read_if_exist_float(section,"frags_r",3)
	local blast_dist = math.max(blast_r,math.min(frags,frags_r))	-- если осколков мало, то бояться их особо не стоит
	local damage = math.min(100,(blast*blast_r^0.5*2)+(frags*frag_hit*2))
	return damage,blast_dist
end

function get_enemyt(section)
	local enemyt = read_if_exist_string(section,"enemy",nil)
	if enemyt then
		local get_cls = function(str) for c,s in pairs(creatures_clslist) do if s == str then return c end end end
		local tmp = str_explode(",",enemyt)
		enemyt = {}
		for _,v in ipairs(tmp) do
			local p = string.find(v,":",1,true)
			if not p then
				abort("weapon_manager: incorrect value enemy for %s",section)
			end
			local cls = get_cls(string.sub(v,1,p-1))
			if not cls then
				abort("weapon_manager: not registered enemy class %s in enemy for %s",string.sub(v,1,p-1),section)
			end
			enemyt[cls] = tonumber(string.sub(v,p+1,-1))
		end
	end
	return enemyt
end

function get_rsect(section)
	local rsect = read_if_exist_string(section,"rsec",nil)
	if rsect then
		rsect = str_explode(",",rsect)
		if #rsect < 3 then
			abort("number of values in rsec(%s) '%s' < 3!",section,#rsect)
		end
	end
	return rsect
end

-- Итак, что нам нужно?
-- 1 Проверить дистанцию до врага +
-- 2 Проверить дистанцию от врага до друзей	+
-- 3 Наличие друзей на линии огня +
-- 4 Подходящесть цели- точно? +

-- определение валидности цели для РПГ-7 или РГ-6
local function valid_target(obj)
	local cls = obj:clsid()
	if cls == clsid.dog_s or cls == clsid.flesh_s then
	   return false
	end
	return true
end
function can_use_blaster(npc,radius)
	radius = radius+3															-- расширим потенциальный радиус поражения
	local enemy = npc:best_enemy()
	if not enemy then
		return true	-- false
	end
	local safe_radius = radius*radius+3
	local npc_pos,enemy_pos = npc:center(),enemy:center()
	printf("[%s]can_use_blaster dist %s radius %s",npc:name(),npc_pos:distance_to(enemy_pos),safe_radius^0.5)
	if npc_pos:distance_to_sqr(enemy_pos) < safe_radius then
		return false
	end
	if not valid_target(enemy) then
		return false
	end
	local friends,npc_id = {},npc:id()
	logc("memory_visible_objects - can_use_blaster (%s alive %s)",npc:name(),npc:alive())
	for o in npc:memory_visible_objects() do
		local obj = o:object()
		if obj and obj:alive() and obj:id() ~= npc_id then
			if IsStalker(obj) and npc:relation(obj) ~= game_object.enemy then
				friends[#friends+1] = obj
			end
		end
	end
	if #friends ~= 0 then
		local dir_aim = vector():sub(enemy_pos,npc_pos):normalize()
		for i=1,#friends do
			local friend = friends[i]
			local friend_pos = friend:center()
			if npc_pos:distance_to_sqr(friend_pos) < safe_radius then
				return false
			end
			local friend_dir = vector():sub(friend_pos,npc_pos)
			if vector():set(friend_dir):normalize():similar(dir_aim,0.3) == 1 then			-- проверяем наличие друга перед собой
				if vector():slide(friend_dir,dir_aim):magnitude() < radius then				-- проверяем наличие друга в потенциальной зоне поражения
--					printf("can_use_blaster[%s]:friend in danger! [%s]",npc:character_name(),friend:name())
					return false
				end
			end
		end
	end
    return true
end

----------------- interface functions ------------------
function weapon_manager:disable(time,full)
	if full then
		self.disabled = true
		self.npc:get_stalker():set_wm(nil)
	else
		self.disabled_temp = time or math.huge
	end
end

function weapon_manager:enable()
	self.disabled_temp = -1
end

function weapon_manager:weapon_is_ready(wpn)
	local wpn = wpn or self.weapon_id and level.object_by_id(self.weapon_id)
	local actit = self.npc:active_item()
	return wpn ~= nil and actit ~= nil and actit:id() == wpn:id() and wpn:get_ammo_in_magazine() > 0 and not wpn:get_weapon().misfire
end

function weapon_manager:get_weapon()
--	if self.disabled then
--		return self.npc:best_weapon()
--	end
	return self.weapon_id and level.object_by_id(self.weapon_id)
end

function weapon_manager:can_take(wpn)
	local sect = wpn:section()
	if wm_modes.forbiddens[sect] == true or wpn:condition() < wm_modes.min_cond then
		return false
	end
	if #self.weapons == 0 then
		return true
	end
	local prm = self:get_weapon_prior(wpn)*0.97
	if self.weapons[1].prm < prm then
		return true
	end
	local best_by_type = self:get_weapon_by_type(weapon_params[sect].typ,true)
--	printf("[%s]can_take %s :fin %s",self.name,wpn:name(),not best_by_type or best_by_type.prm < prm)
	return not best_by_type or best_by_type.prm < prm
end

function weapon_manager:get_weapon_by_type(t,struct)
	if self.disabled then
		self:update_weapon_list()
	end
	for i=1,#self.weapons do
		local w = self.weapons[i]
		if w.typ == t then
			return struct and w or level.object_by_id(w.id)
		end
	end
end

function weapon_manager:get_weapon_by_slot(slot)
	if self.disabled then
		self:update_weapon_list()
	end
	local cini = system_ini()
	for i=1,#self.weapons do
		local obj = level.object_by_id(self.weapons[i].id)
		if obj:get_slot() == slot then
			return obj
		end
	end
end

function weapon_manager:get_weapon_for_distance(dist,by_radius)
	if self.disabled then
		self:update_weapon_list()
	end
	if by_radius then
		return self:pick_for_radius(dist)
	else
		return self:pick_for_distance(dist)
	end
end

function weapon_manager:get_best_by_types()
	if self.disabled then
		self:update_weapon_list()
	end
	local tt = {}
	for i=1,#self.weapons do
		local w = self.weapons[i]
		if not tt[w.typ] then	--or tt[w.typ].prm < w.prm 
			tt[w.typ] = w
		end
	end
	return tt
end

function weapon_manager:set_prefer_weapon(section)
	self.prefer_weapon = section
	self:update_weapon_list()
end

function weapon_manager:change_modes(cm,replace)
	if not self.modes then
		printf("change_modes[%s]:wm not initialized!",self.name)
	end
	self.do_update_list = true
	self.priors_mem = {}
	if (replace or not cm) and self.modes._sc == true then
		local mt = getmetatable(self.modes)
		self.modes = mt.__index
--		table.print(self.modes)
	end
	if not cm then
		return
	end
	local c_pr
	if cm.priority_mode ~= nil or cm.koeffs ~= nil or cm.priors ~= nil then
		c_pr = true
	end
	if cm.types then	-- нужно преобразовать в родной формат
		local tps,ntl = {},{}
		for k,v in ipairs(self.modes.types) do
			tps[v.t] = v.p											-- составим таблицу имеющихся типов
		end
		for k,v in ipairs(wm_modes.types.list) do
			table.insert(ntl,{t = v,p = cm.types[v] or tps[v]})		-- составим новый список типов
		end
		table.sort(ntl,function(a,b) return a.p > b.p end)			-- отсортируем
		cm.types = ntl
	end
	if not replace and self.modes._sc == true then
		for k,v in pairs(cm) do
			self.modes[k] = v
		end
	else
		cm._sc = true
		setmetatable(cm,{__index = self.modes})
		self.modes = cm
	end
	if c_pr then
		read_priors_section(self.modes,"__")
	end
end

function reset_scheme(a)
	if not a.is_stalker then
		return
	end
--	assert(a.obj:alive(),"reset_scheme %s dead?",a.obj)
	local wm = a.obj:get_wm(true)
	if not wm then
		return
	end
	local sect
	if a.section then
		local st = a.st
		if st.ini:line_exist(a.section,"weapon_manager") then
			sect = st.ini:r_string(a.section,"weapon_manager")
		elseif st.ini:line_exist(st.section_logic,"weapon_manager") then
			sect = st.ini:r_string(st.section_logic,"weapon_manager")
		end
	end
	if sect ~= wm.custom_section then
--		printf("reset_scheme[%s]: new sect %s, old %s",wm.name,sect,wm.custom_section)
		wm.custom_section = sect
		if not sect then
			sect = a.obj:name()
		end
--		printf("reset_scheme[%s]: read modes for %s",wm.name,sect)
		wm.modes = read_wm_modes(a.obj:character_community(),m_ranks.get_obj_rank_name(a.obj),sect)
		if wm.modes.disabled == true then
			wm:disable(nil,true)
--			printf("reset_scheme[%s]: disabled",wm.name)
		else
			wm.do_update_list = true
			wm.priors_mem = {}
		end
	end
end

game_object.get_wm = function (npc,enabled_only)
	local st = db.storage[npc:id()].ai
	local wm = st and st.wm
	if wm and not (enabled_only and wm.disabled) then
		return wm
	end
end

--------------------------------------addons---------------------------------------
function get_addon_status(wpn,addon)
	if addon == "sc" then
		return wpn.scope_status
	elseif addon == "sl" then
		return wpn.silencer_status
	elseif addon == "gl" then
		return wpn.grenade_launcher_status
	end
	return 0
end

function get_addon_flag(wpn,with_int)
	local cwpn = wpn:get_weapon()
	local flag = cwpn.addon_flags
	if not with_int then
		if get_addon_status(cwpn,"sc") == 1 then
			flag = flag-1
		end
		if get_addon_status(cwpn,"sl") == 1 then
			flag = flag-4
		end
		if get_addon_status(cwpn,"gl") == 1 then
			flag = flag-2
		end
	end
	return flag
end

local ft = {sc = 1,sl = 4,gl = 2}
function addon_attached(wpn,addon,flag)
	if ft[addon] then
		return bit_and(flag or get_addon_flag(wpn,true),ft[addon]) == ft[addon]
	end
end
