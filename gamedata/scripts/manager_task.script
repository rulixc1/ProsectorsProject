--[[ ----------------------------------------------------------------------------------------------
 File       : manager_task.script (based on task_manager)
 Description: Task handler
 Copyright  : 2005 © GSC Game World
 Author(s)  : GSC Game World, Karlan
--]] ----------------------------------------------------------------------------------------------
--[[ Проблемы менеджера, которые лень править: 
1 скипать квесты на поиск итемов надо по секции, а не по айди
2 сделать какое-то более логичное "обнуление" веток квестов, возможно сделать рандомные ветки
--// TODO: сделать четыре типа награды: static, random. smart, custom
]]
--//-----------------------------------------------------------------
--// Flags for enable output of the debug information
--//-----------------------------------------------------------------
_DEBUG_ = true --// file under debugging?
_DEBUG_GSC_ = _DEBUG_ and false --// only for scripts by GSC
--//-----------------------------------------------------------------
--//-----------------------------------------------------------------------------------------------
--// Variables
--//-----------------------------------------------------------------------------------------------
local loaded = false
--//--------------------
local random_task = nil
local parent_by_story = {
    [003] = "trader",
    [500] = "barman",
    [902] = "ecolog",
    [507] = "dolg",
    [707] = "freedom",
    [006] = "wolf",
    [004] = "shustriy",
    [510] = "drunk_dolg",
    [504] = "hunter",
    [518] = "zastava_commander",
    [506] = "petrenko",
    [607] = "lisiy",
    [515] = "mercenary",
}
local story_by_parent = {
    trader              = 003,
    barman              = 500,
    ecolog              = 902,
    dolg                = 507,
    freedom             = 707,
    wolf                = 006,
    shustriy            = 004,
    drunk_dolg          = 510,
    hunter              = 504,
    zastava_commander   = 518,
    petrenko            = 506,
    lisiy               = 607,
    mercenary           = 515,
}
local return_task_by_type = {
    eliminate_lager = "return_for_reward",
    defend_lager    = "return_for_reward",
    kill_stalker    = "return_for_reward",
    artefact        = "return_for_reward_bring",
    monster_part    = "return_for_reward_bring",
    find_item       = "return_for_reward_bring",
    find_few_items  = "return_for_reward_bring", --// Karlan: новый вид однотипных заданий: поиск нескольких предметов
}
--//-----------------------------------------------------------------------------------------------
--// Global functions
--//-----------------------------------------------------------------------------------------------
class "CRandomTask"
--//--------------------
function CRandomTask:get_reward(str, data, mode) --// ##заготовка## TODO:#####
    --// Karlan->Karlan: сам себе на будущее: собираюсь делать комплексный ключ в таблице в формате parent..type..уровень квеста, уровень квеста вещь очень условная, будем надеятся и верить, что все соблюдают каноны и у всех чем больше этот уровень, тем сложнее квест, или хотябы этот уровень вообще есть, иначе беда
    str = mode and str or (tonumber(str) or str) --// dirty hack :)
    local parent, _type, level = data.parent, data.type, data.name:sub(-1)
    if is_nil(str) then return nil end --/> строки нет, награды тоже
    if not mode and is_string(str) and str == 'random' then mode = true end --// dirty hack :)
    local check = mode and is_string or is_number
    assert(check(str), 'bad argument #1 to CRandomTask:get_reward (%s or nil excepted, got %s)', mode and 'string' or 'number', type(str))
    if str ~= 'random' then return (mode and parse_spawns(str) or str), false end
end
--//--------------------
function CRandomTask:__init()
    self.task_ini = ini_file("misc\\manager_task\\manager_task.ltx")
    assert(self.task_ini:section_exist("list"), "There is no section [list] in manager_task.ltx")
    self.task_phrase_id = 100 --// Karlan: и здесь магия
    self.task_info = {}
    local id, curr_task_info = '', nil
    for i=0, self.task_ini:line_count("list")-1 do
        _, id = self.task_ini:r_line("list",i,"","")
        assert(self.task_ini:section_exist(id), "There is no section [%s] in manager_task.ltx", id)
        assert(self.task_ini:line_exist(id, "type"), "Task manager error: no type in section [%s]", id)

        self.task_info[tostring(id)]    = {}
        curr_task_info                  = self.task_info[tostring(id)]
        curr_task_info.type             = self.task_ini:r_string(id, "type")
        curr_task_info.name             = id
        curr_task_info.parent           = READ_IF_EXISTS(self.task_ini, 'r_string', id, 'parent', 'nil')
        curr_task_info.complex_type     = curr_task_info.type .. (curr_task_info.parent~='nil' and '_' .. self.task_info[id].parent or '')
        curr_task_info.target           = READ_IF_EXISTS(self.task_ini, 'r_string', id, 'target', nil)
        local target_items              = READ_IF_EXISTS(self.task_ini, 'r_string', id, 'target_items', nil)
        curr_task_info.target_items     = target_items and parse_spawns(target_items) or nil
        curr_task_info.text             = READ_IF_EXISTS(self.task_ini, 'r_string', id, 'text', nil)
        curr_task_info.description      = READ_IF_EXISTS(self.task_ini, 'r_string', id, 'description', nil)
        curr_task_info.time             = READ_IF_EXISTS(self.task_ini, 'r_float', id, 'time', nil)
        curr_task_info.idle_time        = READ_IF_EXISTS(self.task_ini, 'r_float', id, 'idle_time', 24*60*60)
        curr_task_info.prior            = READ_IF_EXISTS(self.task_ini, 'r_float', id, 'prior', 0)
        curr_task_info.init_condition   = self.task_ini:line_exist(id, "init_condition") and parse_condlist(self.task_ini:r_string(id, "init_condition")) or nil
        local stuff, save               = self:get_reward(READ_IF_EXISTS(self.task_ini, 'r_string', id, 'reward_item', nil), curr_task_info, true)
        curr_task_info.reward_item      = stuff
        curr_task_info.reward_item_save = save
        stuff, save                     = self:get_reward(READ_IF_EXISTS(self.task_ini, 'r_string', id, 'reward_money', nil), curr_task_info, false)
        curr_task_info.reward_money     = stuff
        curr_task_info.reward_money_save= save
        curr_task_info.reward_rank      = READ_IF_EXISTS(self.task_ini, 'r_float', id, 'reward_rank', 0)
        curr_task_info.reward_reputation= READ_IF_EXISTS(self.task_ini, 'r_float', id, 'reward_reputation', nil)
        curr_task_info.reward_goodwill  = READ_IF_EXISTS(self.task_ini, 'r_float', id, 'reward_goodwill', nil)
        curr_task_info.reward_relation  = parse_key_value(READ_IF_EXISTS(self.task_ini, 'r_string', id, 'reward_relation', nil))
        curr_task_info.condlist         = parse_condlist(READ_IF_EXISTS(self.task_ini, 'r_string', id, 'condlist', 'true'))
        curr_task_info.need_return      = READ_IF_EXISTS(self.task_ini, 'r_bool', id, 'need_return', true)
        curr_task_info.kill_time        = READ_IF_EXISTS(self.task_ini, 'r_bool', id, 'kill_time', true)
        curr_task_info.init_phrase_id   = self:gen_phrase_id()
        curr_task_info.desc_phrase_id   = self:gen_phrase_id()
        curr_task_info.yes_phrase_id    = self:gen_phrase_id()
        curr_task_info.no_phrase_id     = self:gen_phrase_id()
        curr_task_info.completed_phrase_id = self:gen_phrase_id()
        curr_task_info.rewarded_phrase_id = self:gen_phrase_id()
        curr_task_info.enabled          = true --// По умолчанию квест доступен для выдачи
        --// Доступен ли квест по своим свойствам. По умолчанию всегда недоступен.
        --// Этот параметр зависит от наличия целей для квестов и того срабатывает ли прекондишн квеста
        curr_task_info.enabled_props    = false
        curr_task_info.status           = "normal" --// Статус квеста, может быть: "normal", "selected", "completed", "refused", "failed", "rewarded"
    end
    --// Создание дополнительных ассоциативных таблиц для облегчения поиска
    self.task_id_by_type            = {} --// По типу квеста
    self.task_id_by_parent          = {} --// По типу вендора
    self.task_id_by_yes_phrase_id   = {} --// По id фразы согласия на квест
    self.task_id_by_init_phrase_id  = {} --// По id фразы выдачи квеста
    self.task_id_by_desc_phrase_id  = {}
    self.task_id_by_rewarded_phrase_id = {}
    self.active_task_by_type        = {}
    self.task_id_self_inited        = {} --// По самовыдаваемости
    for k,v in pairs(self.task_info) do
        if self.task_id_by_type[v.type] == nil then
            self.task_id_by_type[v.type] = {}
        end
        table.insert(self.task_id_by_type[v.type], k)
        if self.task_id_by_parent[v.parent] == nil then
            self.task_id_by_parent[v.parent] = {}
        end
        table.insert(self.task_id_by_parent[v.parent], k)
        self.task_id_by_yes_phrase_id[tostring(v.yes_phrase_id)] = k
        self.task_id_by_init_phrase_id[tostring(v.init_phrase_id)] = k
        self.task_id_by_desc_phrase_id[tostring(v.desc_phrase_id)] = k
        self.task_id_by_rewarded_phrase_id[tostring(v.rewarded_phrase_id)] = k
        if is_table(v.init_condition) then
            table.insert(self.task_id_self_inited, k)
        end
    end
end
function CRandomTask:gen_phrase_id()
    self.task_phrase_id = self.task_phrase_id + 1
    return tostring(self.task_phrase_id)
end
function CRandomTask:save(p)
    local task_info_buff = {}
    for k,v in pairs(self.task_info) do
        task_info_buff[k]                   = {}
        task_info_buff[k].enabled           = v.enabled
        task_info_buff[k].enabled_props     = v.enabled_props
        task_info_buff[k].status            = v.status
        task_info_buff[k].selected_target   = v.selected_target or -1
        task_info_buff[k].last_task_time    = v.last_task_time
        if v.reward_item_save then
            task_info_buff[k].reward_item   = v.reward_item
        end
        if v.reward_money_save then
            task_info_buff[k].reward_money  = v.reward_money
        end
    end
    p.task_info = task_info_buff
    p.active_task_by_type = self.active_task_by_type
end
function CRandomTask:load(p)
    for k,v in pairs(p.task_info) do
        self.task_info[k].enabled           = v.enabled
        self.task_info[k].enabled_props     = v.enabled_props
        self.task_info[k].status            = v.status
        self.task_info[k].selected_target   = v.selected_target
        self.task_info[k].last_task_time    = v.last_task_time
        if is_table(v.reward_item) then
            self.task_info[k].reward_item   = v.reward_item
        end
        if is_number(v.reward_money) then
            self.task_info[k].reward_money  = v.reward_money
        end
        if self.task_info[k].type == "defend_lager" and self.task_info[k].selected_target ~= -1 then
            local defend_object = sim:object(self.task_info[k].selected_target)
            self.task_info[k].defend_target = cfg_get_number(defend_object:spawn_ini(), "random_task", "defend_target", nil, true)
        end
    end
    self.active_task_by_type = p.active_task_by_type
end
--// Возвращает идентификатор вендора, с которым мы говорим
function CRandomTask:get_parent(npc)
    local story_id = get_sid(npc)
    assert(parent_by_story[story_id], "Task manager error: wrong parent story_id[%s]", story_id)
    return parent_by_story[story_id]
end
--// Есть ли у игрока хоть одно задание от данного вендора
function CRandomTask:active_parent_task(actor, npc)
    local parent = self:get_parent(npc)
    for k,v in pairs(self.active_task_by_type) do
        if self.task_info[v].parent == parent and (self.task_info[v].status == "selected" or self.task_info[v].status == "completed") then
            return true
        end                
    end
    return false
end
--// Есть ли игрока завершенные задания (которые осталось только сдать)
function CRandomTask:have_completed_job(actor, npc)
    local parent = self:get_parent(npc)
    for k,v in pairs(self.active_task_by_type) do
        if self.task_info[v].parent == parent and self.task_info[v].status == "completed" then
            return true
        end                
    end
    return false
end
--// Выдача квеста игроку
function CRandomTask:action_give_task(actor, npc, p1, p2)
    local task = CGameTask()
    local task_desc = self.task_info[self.task_id_by_yes_phrase_id[p2]]
    task:load(task_desc.complex_type)
    task:set_title(task_desc.type)
    if is_string(task_desc.description) then
        task:set_description(task_desc.description) --// Karlan: будем надеятся что айди всегда совпадет с текстовым айди, в противном случае надо вводить новый ключ
        local oo = task:get_objective(0)
        oo:set_article_id(task_desc.description)
    end
    local objective = SGameTaskObjective(task, 1)
    objective:set_description(task_desc.name)
    --// Выбираем текущую цель квеста
    if is_table(task_desc.target_objects) then
        self.task_info[self.task_id_by_yes_phrase_id[p2]].selected_target = task_desc.target_objects[math.random(#task_desc.target_objects)]
    end
    if task_desc.type == "eliminate_lager" then
        objective:set_map_hint(task_desc.text)
        objective:set_map_location("eliminate_lager_location")
        objective:set_object_id(task_desc.selected_target)
    elseif task_desc.type == "defend_lager" then
        objective:set_map_hint(task_desc.text)
        objective:set_map_location("defend_lager_location")
        objective:set_object_id(task_desc.selected_target)

        local defend_object = sim:object(task_desc.selected_target)
        local sm_ini = defend_object:spawn_ini()
        self.task_info[self.task_id_by_yes_phrase_id[p2]].defend_target = cfg_get_number(sm_ini, "random_task", "defend_target", nil, true)
    elseif task_desc.type == "kill_stalker" then
        objective:set_map_hint(task_desc.text)
                -- if task_desc.time then --// Karlan->Karlan: надо не забыть о том, что собрался переделывать все метки на что-то более вменяемое при глобальной переделке менеджера
        -- objective:set_map_location("secondary_task_eliminate_squad_complex_spot")
        -- else
        objective:set_map_location("kill_stalker_location")
        -- end
        objective:set_object_id(task_desc.selected_target)
    elseif task_desc.type == "find_item" then
        objective:set_map_hint(task_desc.text)
        -- if task_desc.time then
        -- objective:set_map_location("secondary_task_location_complex_recover_item")
        -- else
        objective:set_map_location("find_item_location")
        -- end
        objective:set_object_id(task_desc.selected_target)
    end
	if task_desc.type == "storyline" then
		level.map_add_object_spot(task_desc.selected_target, "ui_storyline_task_blink", "")
	else
		level.map_add_object_spot(task_desc.selected_target, "ui_secondary_task_blink", "")
	end
    --// Карлан: указание статикового дескрипшена под кокнретный обжектив, при переписывание менеджера стоит учесть возможность
    --// to ALL: возможно стоит пересмотреть дизайн функций, но без глобальной переделки я не взялся сделать по логике
    -- objective:set_real_description(task_desc.description) --// Karlan: дескрипшн под первый обжектив (но их в природе нет)
    objective:add_complete_func("manager_task.task_complete")
    task:add_objective(objective)
    if task_desc.need_return then
        objective = SGameTaskObjective(task, 2)
        objective:set_description(return_task_by_type[task_desc.type])
        
        objective:set_map_hint(return_task_by_type[task_desc.type])
        objective:set_map_location("blue_location")
        objective:set_object_id(alife():story_object(tonumber(story_by_parent[task_desc.parent])).id)
        -- objective:set_real_description(task_desc.description) --// Karlan: дескрипшн под второй обжектив (но их в природе нет)
        if task_desc.type == "eliminate_lager" or task_desc.type == "defend_lager" or task_desc.type == "kill_stalker" then
            objective:kill_time(task_desc.kill_time)
        end
        task:add_objective(objective)
    end
    local time = 0
    if is_number(task_desc.time) then
        time = task_desc.time * 1000
    end
    actor:give_task(task,time,false)
    --// дизаблим все остальные задания данного типа, так как игрок не может одновременно обладать двумя заданиями одного типа.
    self.task_info[self.task_id_by_yes_phrase_id[p2]].status = "selected"
    self.active_task_by_type[task_desc.complex_type] = self.task_id_by_yes_phrase_id[p2]
    for k,v in pairs(self.task_info) do
        if v.complex_type == task_desc.complex_type then
            v.enabled = false
        end
    end
end
--// Отказ игроком от квеста
function CRandomTask:action_refuse_task(actor, npc, p1, p2)
    local task_desc = self.task_info[self.task_id_by_yes_phrase_id[p2]]
    local gw = task_desc.reward_goodwill
    if is_number(gw) and not math.is_zero(gw) then
        gw = math.is_positive(gw) and gw*-1 or gw
        if math.random() < 0.65 then gw = gw*2 end
        change_npc_goodwill(npc, actor, gw)
    end
    --// Делаем доступными все задания данного типа
    self.task_info[self.task_id_by_yes_phrase_id[p2]].status = "refused"
    self.task_info[self.active_task_by_type[task_desc.complex_type]].selected_target = nil
    for k,v in pairs(self.task_info) do
        if v.complex_type == task_desc.complex_type then
            v.enabled = true
        end
    end
end
--// Проверяем, не выполнен ли таск
function CRandomTask:task_complete(p1, p2)
    local sel_task = self.task_info[self.active_task_by_type[p1]]
    assert(sel_task, "WRONG RANDOM TASK %s %s %s", p1, p2, self.task_info)
    if p2 == 0 then
        if (not sel_task.need_return and sel_task.status == "completed") or sel_task.status == "rewarded" then
            self.task_info[self.active_task_by_type[p1]].last_task_time = game.get_game_time()
            return true
        end
    end
    if p2 == 1 then
        if string.find(p1, "eliminate_lager") ~= nil then
            local sobj = sim:object(sel_task.selected_target)
            if sobj and sobj.gulag:get_population_comed() == 0 then
                self.task_info[self.active_task_by_type[p1]].status = "completed"
                return true
            end
        elseif string.find(p1, "defend_lager") ~= nil then
            --// Квест выполнен потому что рейд прекратился
            if m_gulag.getGulagState(sel_task.defend_target) == 0 then
                self.task_info[self.active_task_by_type[p1]].status = "completed"
                return true
            end
        elseif string.find(p1, "kill_stalker") ~= nil then
            local sobj = sim:object(sel_task.selected_target)
            assert(sobj, "OBJ = nil for task %s, selected_target = %s", self.active_task_by_type[p1], sel_task.selected_target)
            assert(sobj.alive, "OBJ.ALIVE = nil for task %s, OBJ.NAME = %s", self.active_task_by_type[p1], sobj:name())  
            if not sobj:alive() then
                self.task_info[self.active_task_by_type[p1]].status = "completed"
                return true
            end
        elseif string.find(p1, "artefact") ~= nil then
            if actor:object(sel_task.target) ~= nil then
                self.task_info[self.active_task_by_type[p1]].status = "completed"
                return true
            end
        elseif string.find(p1, "monster_part") ~= nil then
            if actor:object(sel_task.target) ~= nil then
                self.task_info[self.active_task_by_type[p1]].status = "completed"
                return true
            end
        elseif string.find(p1, "find_item") ~= nil then
            if actor:object(sel_task.target) ~= nil then
                self.task_info[self.active_task_by_type[p1]].status = "completed"
                return true
            end
        elseif string.find(p1, "find_few_items") ~= nil then
            if has_kv_objects(sel_task.target_items) then
                self.task_info[self.active_task_by_type[p1]].status = "completed"
                return true
            end
        end
    end
    return false
end
--// Проверяем, не профейлен ли таск
function CRandomTask:task_fail(p1, p2)
    if p2 == 0 then
        local task_desc = self.task_info[self.active_task_by_type[p1]]
        assert(task_desc, "WRONG RANDOM TASK %s %s %s", p1, p2, self.active_task_by_type[p1])
        local parent = sim:story_object(story_by_parent[task_desc.parent])
        if parent and (parent.alive and not parent:alive()) then
            self.task_info[self.active_task_by_type[p1]].status = "failed"
            self.task_info[self.active_task_by_type[p1]].last_task_time = game.get_game_time()
            return true        
        end
        if task_desc.status == "refused" or task_desc.status == "failed" then
            self.task_info[self.active_task_by_type[p1]].last_task_time = game.get_game_time()
            return true
        end
        if (string.find(p1, "defend_lager") ~= nil) and sim:object(task_desc.selected_target).gulag:get_population_comed() == 0 then
            self.task_info[self.active_task_by_type[p1]].status = "failed"
            self.task_info[self.active_task_by_type[p1]].last_task_time = game.get_game_time()
            return true
        end
    end
    return false
end
--// Обнуление переменных при завершении или провале таска
function CRandomTask:task_callback(p1, p2, state)
    if p2 ~= 0 then return end
    if not self.active_task_by_type[p1] then return end
    if state == task.completed then
        self.task_info[self.active_task_by_type[p1]].status = "normal"
        --// восстановление других заданий данного типа
        for k,v in pairs(self.task_info) do
            if v.complex_type == self.task_info[self.active_task_by_type[p1]].complex_type then
                v.enabled = true
            end
        end
        self.active_task_by_type[p1] = nil    
    elseif state == task.fail then
        local gw = self.task_info[self.active_task_by_type[p1]].reward_goodwill
        local parent = sim:story_object(story_by_parent[self.task_info[self.active_task_by_type[p1]].parent])
        if is_number(gw) and gw~=0 and is_userdata(parent) and parent.force_set_goodwill then --// Karlan: у сторилайновых парента нет
            gw = math.is_positive(gw) and gw*-1 or gw
            if math.random() < 0.65 then gw = gw*2 end --// Karlan: ну не повезло :(
            parent:force_set_goodwill(gw, actor_id) --// Karlan->Karlan: здесь форсируем, в принципе похер конечно, но можно через оболочку реализовать копию функционала, либо прямо в движке
        end
        self.task_info[self.active_task_by_type[p1]].status = "normal"
        --// восстановление других заданий данного типа
        for k,v in pairs(self.task_info) do
            if v.complex_type == self.task_info[self.active_task_by_type[p1]].complex_type then
                v.enabled = true
            end
        end
        self.active_task_by_type[p1] = nil    
    end
end
--// Высчитываем прекондишны для тасков попутно возвращая что вендор может дать хоть какую-нибудь работенку, функция выглядит архидебильно!
function CRandomTask:parent_can_task(actor, npc, p1, p2, p3)
    local parent = self:get_parent(npc)
    local avail = false
    self:task_avail(_,_,_,_,_, "reset")
    for _,v in ipairs(self.task_id_by_parent[parent]) do  
        if self:task_avail(_,_,_,_, self.task_info[v].init_phrase_id, true) then
            avail = true
        end
    end
    return avail
end
--// Выводит список доступных квестов
function CRandomTask:action_task_show(npc, actor)
    local parent = self:get_parent(npc)    
    for _,v in ipairs(self.task_id_by_parent[parent]) do        
        if self:task_avail(_,_,_,_, self.task_info[v].init_phrase_id) then
            local task_texture, task_rect = get_texture_info("ui_iconsTotal_"..self.task_info[v].type, "ui_iconsTotal_locations")
            local msg = colors.gray..(self.task_info[v].type:translate())..': '..colors.text..(self.task_info[v].name:translate():lower())..'.'
            actor:give_talk_message(msg, task_texture, task_rect, "iconed_trade_info")
        end
    end
end
--// Проверка доступен ли текущий таск для выдачи
function CRandomTask:task_avail(_,_,_,_, p3, calculate)
    local task_desc = self.task_info[self.task_id_by_init_phrase_id[p3]]
    --// Если calculate == true то нужно проверять check_task_props, инача просто вернуть значения.
    if calculate == "reset" then        
        self.current_parent_type_prior = {}
        return
    elseif calculate == true then
        self:check_task_props(self.task_id_by_init_phrase_id[p3])

        local t = task_desc.enabled and task_desc.enabled_props and task_desc.init_condition == nil

        --// Устанавливать обрезания по приоритетам тут.
        if t == true and (self.current_parent_type_prior[task_desc.complex_type] == nil or self.current_parent_type_prior[task_desc.complex_type] > task_desc.prior ) then
            self.current_parent_type_prior[task_desc.complex_type] = task_desc.prior
        end

        return t
    end
    if self.current_parent_type_prior[task_desc.complex_type] ~= nil and self.current_parent_type_prior[task_desc.complex_type] < task_desc.prior then
        return false
    end
    return task_desc.enabled and task_desc.enabled_props and task_desc.init_condition == nil
end
--// Проверка свойств таска
function CRandomTask:check_task_props(task_id)
    --// Проверка по активным заданиям данного типа у вендора.
    if self.active_task_by_type[self.task_info[task_id].complex_type] ~= nil then
        self.task_info[task_id].enabled_props = false
        return
    end
    --// Проверка по кондлисту
    local section = xr_logic.pick_section_from_condlist(actor, self.task_info[task_id].condlist)
    if section == nil or section == 'nil' then
        self.task_info[task_id].enabled_props = false
        return
    end
    --// Проверка по таймауту
    if self.task_info[task_id].last_task_time ~= nil and game.get_game_time():diffSec(self.task_info[task_id].last_task_time) < self.task_info[task_id].idle_time then
        self.task_info[task_id].enabled_props = false
        return
    end
    --// Проверка по таргету
    if self.task_info[task_id].type == "eliminate_lager" then
        if self.task_info[task_id].target_objects == nil then
            self.task_info[task_id].enabled_props = false
            return
        end
        for k,v in pairs(self.task_info[task_id].target_objects) do
            local gulag = alife():object(v).gulag
            if gulag:get_population_comed() > (gulag:get_capacity()/2) then
                self.task_info[task_id].enabled_props = true
                return 
            end
        end
        self.task_info[task_id].enabled_props = false
        return
    elseif self.task_info[task_id].type == "defend_lager" then
        if self.task_info[task_id].target_objects == nil then
            self.task_info[task_id].enabled_props = false
            return
        end
        for k,v in pairs(self.task_info[task_id].target_objects) do
            local defend_object = alife():object(v)
            local sm_ini = defend_object:spawn_ini()
            local defend_target = cfg_get_number(sm_ini, "random_task", "defend_target", nil, true)
            if m_gulag.getGulagState(defend_target) == 1 then
                self.task_info[task_id].enabled_props = true
                return
            end
        end
        self.task_info[task_id].enabled_props = false
        return
    elseif self.task_info[task_id].type == "kill_stalker" then
        if self.task_info[task_id].target_objects == nil 
        or (is_table(self.task_info[task_id].target_objects) and not next(self.task_info[task_id].target_objects)) --// Karlan: может мужичка уже и без нас того?
        then 
            self.task_info[task_id].enabled_props = false
            return
        end
        for k,v in pairs(self.task_info[task_id].target_objects) do --// Karlan->Karlan: проверить целостность списка, возможно опять джит-причуды
            local obj = sim:object(v)
            --// Karlan: а вдруг резко грохнулся об чето мужичок, да так, что потерли все о нем в лучших традициях 1984?
            if is_userdata(obj) then
                assert(is_function(obj.alive), 'INVALID TARGET in [%s]: object doesnt creature, method alive() doesnt exist in [%s]', task_id, obj)
                if obj:alive() then
                    self.task_info[task_id].enabled_props = true
                    return
                else
                    table.remove(self.task_info[task_id].target_objects, k)
                end
            else
                warning('INVALID OBJECT in [%s]: try print targets ~> %s', task_id, self.task_info[task_id].target_objects)
                table.remove(self.task_info[task_id].target_objects, k)
            end
        end
        self.task_info[task_id].enabled_props = false
        return
    elseif self.task_info[task_id].type == "find_item" or self.task_info[task_id].type == "find_few_items"  then
        if self.task_info[task_id].target_objects == nil or #self.task_info[task_id].target_objects == 0 then
            self.task_info[task_id].enabled_props = false
            return
        end
        for k,v in pairs(self.task_info[task_id].target_objects) do
            local obj = sim:object(v)
            if obj then
                --// Нужно игнорировать предметы, которые находяться у вендоров
                if obj.parent_id ~= INVALID_ID then --// Karlan: для бесхозных дальше идти нет смысла
                    for kk,vv in pairs(parent_by_story) do
                        local parent = sim:story_object(kk)
                        if parent and obj.parent_id == parent.id then
                            self.task_info[task_id].enabled_props = false --// Игнорим предмет
                            return                            
                        end
                    end
                end
                self.task_info[task_id].enabled_props = true
                return
            end    
            self.task_info[task_id].enabled_props = false
            return
        end
    else
        self.task_info[task_id].enabled_props = true
        return        
    end
end
--// Проверяем можем ли мы сейчас выдать какой либо самоинициализующийся таск
function CRandomTask:actor_update()
    for k,v in pairs(self.task_id_self_inited) do
        if self.task_info[v].status == "normal" then
            self:check_task_props(v)
            local section = xr_logic.pick_section_from_condlist(actor, self.task_info[v].init_condition)
            if self.task_info[v].enabled_props == true and self.task_info[v].enabled == true and section ~= nil and section ~= 'nil' then
                self:action_give_task(actor, nil, nil, self.task_info[v].yes_phrase_id)
            end
        end
    end
end
--// Проверяется наличие квестовых предметов
function CRandomTask:completed_task(actor, npc, p1, p2, p3)
    if not p3 or not self.task_id_by_desc_phrase_id[p2] then return false end
    local task_desc = self.task_info[self.task_id_by_desc_phrase_id[p2]]
    if task_desc.status ~= "completed" then return false end
    local can_finish = true
    if task_desc.type == "artefact" or task_desc.type == "monster_part" or task_desc.type == "find_item" then
        if actor:object(task_desc.target) == nil then
            can_finish = false
        end
    elseif task_desc.type == "find_few_items" then
        if not has_kv_objects(task_desc.target_items) then
            can_finish = false
        end
    end
    return can_finish
end
--// Проверяется является ли текущий таск выданным игроку
function CRandomTask:active_task(actor, npc, p1, p2, p3)
    return self.task_info[self.task_id_by_init_phrase_id[p3]].status == "selected" or self.task_info[self.task_id_by_init_phrase_id[p3]].status == "completed"
end
--// Показываем награду
function CRandomTask:action_show_reward(npc, actor, p1, p2)
    local task_desc = self.task_info[self.task_id_by_desc_phrase_id[p2]]
    local items, money, goodwill = nil, task_desc.reward_money, task_desc.reward_goodwill
    if is_table(task_desc.reward_item) then
        items = ''
        for k,v in pairs(task_desc.reward_item) do
            local tail = (k==#task_desc.reward_item) and '' or ', '
            local count = (v.prob>1 or ammo_sections[v.section]) and ' - '..(v.prob*(ammo_sections[v.section] and cfg_get_number(sini, v.section, 'box_size', 1) or 1))..' шт.' or ''
            items = get_string_name(v.section) .. count .. tail
        end
    end
    if not items and not money and not goodwill then return end
    local need_return_tail = (task_desc.need_return and (colors.default..' '..game.translate_string('need_return_show_reward')) or '')
    local task_texture, task_rect = get_texture_info("ui_inGame2_Predmet_poluchen")
    actor:give_talk_message("Результаты выполнения будут такими:", "ui\\ui_iconstotal", Frect():set(0,0,10,10), "simple_answer_item")
    if items then actor:give_talk_message(colors.gray..'Предметы: '..colors.default..items, task_texture, task_rect, "iconed_trade_info") end
    task_texture, task_rect = get_texture_info("ui_inGame2_Dengi_polucheni")
    if money then actor:give_talk_message(colors.gray..'Деньги: '..colors.default..money.." руб." .. need_return_tail, task_texture, task_rect, "iconed_trade_info") end
    task_texture, task_rect = get_texture_info("ui_inGame2_PD_Diplomat")
    if goodwill then actor:give_talk_message(colors.gray..'Улучшение деловой благосклонности: '..colors.green..'+'..goodwill .. need_return_tail, task_texture, task_rect, "iconed_trade_info") end
end
--// Создается диалог актера, в котором будут выдаваться задания.
function CRandomTask:init_task_dialog(dlg, parent)
    local phr = dlg:AddPhrase("tm_seek_new_job","0","",-10000)
    local phrase_script = phr:GetPhraseScript()

    phr = dlg:AddPhrase("tm_"..parent.."_list_job","1","0",-10000)
    phrase_script = phr:GetPhraseScript()
    phrase_script:AddAction("manager_task.action_task_show")
    phrase_script:AddPrecondition("manager_task.precondition_vendor_can_task")
        
    phr = dlg:AddPhrase("tm_"..parent.."_has_no_job","2","0",-10000)
    phrase_script = phr:GetPhraseScript()
    phrase_script:AddPrecondition("manager_task.precondition_vendor_cannot_task")
    
    for k,v in pairs(self.task_id_by_parent[parent]) do
        phr = dlg:AddPhrase(self.task_info[v].name, tostring(self.task_info[v].init_phrase_id), "1", -10000)        
        phrase_script = phr:GetPhraseScript()
        phrase_script:AddPrecondition("manager_task.precondition_task_avail")

        phr = dlg:AddPhrase(self.task_info[v].text, tostring(self.task_info[v].desc_phrase_id), tostring(self.task_info[v].init_phrase_id), -10000)
        phrase_script = phr:GetPhraseScript()
        phrase_script:AddAction("manager_task.action_show_reward")
        
        phr = dlg:AddPhrase("tm_seek_job_yes", tostring(self.task_info[v].yes_phrase_id), tostring(self.task_info[v].desc_phrase_id), -10000)
        phrase_script = phr:GetPhraseScript()
        phrase_script:AddAction("manager_task.action_give_task")

        phr = dlg:AddPhrase("tm_seek_job_no", tostring(self.task_info[v].no_phrase_id), tostring(self.task_info[v].desc_phrase_id), -10000)
    end

    dlg:AddPhrase("tm_seek_job_abandon","3","1",-10000)
end
--// Функция, в которой будет выдаваться вещевая награда за выполненные квесты
function CRandomTask:task_reward(npc, actor, p1, p2)
    local parent = self:get_parent(npc)
    local v = self.task_id_by_rewarded_phrase_id[p2]
    local task_desc = self.task_info[v]
    if task_desc == nil or task_desc.status ~= "completed" or task_desc.parent ~= parent then return end
    local can_finish = true
    if task_desc.type == "artefact" or task_desc.type == "monster_part" or task_desc.type == "find_item" then
        if actor:object(task_desc.target) == nil then
            can_finish = false
        else
            m_talks.relocate_item_section(npc, task_desc.target, "out")
        end
    elseif task_desc.type == "find_few_items" then
        if not has_kv_objects(task_desc.target_items) then
            can_finish = false
        else
            for _,vv in ipairs(task_desc.target_items) do
                local obj = actor:object(vv.section)
                for i=1, vv.prob do
                    actor:transfer_item(obj, npc)
                end
                manager_news.relocate_item("out", obj, obj:is_ammo() and obj:get_ammo_box_curr()*vv.prob or vv.prob, cop_style)
            end
        end
    end
    if not can_finish then return end
    self.task_info[v].status = "rewarded"
    if is_number(task_desc.reward_money) then
        m_talks.relocate_money(npc, task_desc.reward_money, "in")
    end
    if is_table(task_desc.reward_item) then
        for _,vv in ipairs(task_desc.reward_item) do
            m_talks.relocate_item_section(npc, vv.section, "in", vv.prob)
        end
    end
    if is_number(task_desc.reward_reputation) then
        actor:change_character_reputation(task_desc.reward_reputation)
    end
    if is_number(task_desc.reward_goodwill) then
        change_npc_goodwill(npc, actor, task_desc.reward_goodwill)
    end
    if is_table(task_desc.reward_relation) then
        for kk,vv in pairs(task_desc.reward_relation) do
            relation_registry.change_community_goodwill(kk, actor_id, tonumber(vv))
        end
    end
    if is_number(task_desc.reward_rank) then
        local color = task_desc.type == "storyline" and colors.coral or colors.default
        actor_stats.add_points("quests", colors.gray..npc:character_name()..': '..color..game.translate_string(task_desc.name), 1, task_desc.reward_rank)
        actor:set_character_rank(actor:character_rank() + task_desc.reward_rank)
    end
end
--// Функция, в которой будет выдаваться вещевая награда за выполненные сторилайновые квесты
function CRandomTask:task_reward_storyline(task)
    local task_desc = self.task_info[task:get_id()]
    if task_desc == nil or task_desc.type ~= "storyline" then return end
    if is_number(task_desc.reward_reputation) then
        actor:change_character_reputation(task_desc.reward_reputation)
    end
    if is_number(task_desc.reward_goodwill) then
        change_npc_goodwill(npc, actor, task_desc.reward_goodwill)
    end
    if is_table(task_desc.reward_relation) then
        for kk,vv in pairs(task_desc.reward_relation) do
            relation_registry.change_community_goodwill(kk, actor_id, tonumber(vv))
        end
    end
    if is_number(task_desc.reward_rank) then
        actor_stats.add_points("quests", colors.coral..game.translate_string(task_desc.name), 1, task_desc.reward_rank)
        actor:set_character_rank(actor:character_rank() + task_desc.reward_rank)
    end
end
--// Создается диалог актера, в котором будут приниматься задания
--// Karlan->Karlan: здесь возможно лучше будет закешировать квестодателя чтобы не городить 100500 функций инита
function CRandomTask:init_reward_dialog(dlg, parent)
    local phr = dlg:AddPhrase("tm_reward_job","0","",-10000)
    local phrase_script = phr:GetPhraseScript()
    phr = dlg:AddPhrase("tm_"..parent.."_job_ask", "2", "0", -10000)
    phrase_script = phr:GetPhraseScript()
    --// Список возможных квестов
    for k,v in pairs(self.task_id_by_parent[parent]) do
        phr = dlg:AddPhrase(self.task_info[v].name, tostring(self.task_info[v].init_phrase_id), "2", -10000)
        phrase_script = phr:GetPhraseScript()        
        phrase_script:AddPrecondition("manager_task.precondition_active_task")
        
        phr = dlg:AddPhrase("tm_"..parent.."_job_what", tostring(self.task_info[v].desc_phrase_id), tostring(self.task_info[v].init_phrase_id), -10000)
        
        phr = dlg:AddPhrase("tm_job_refuse", tostring(self.task_info[v].yes_phrase_id), tostring(self.task_info[v].desc_phrase_id), -10000)
        phrase_script = phr:GetPhraseScript()
        phrase_script:AddAction("manager_task.action_refuse_task")
        phrase_script:AddPrecondition("manager_task.precondition_notcompleted_task")
            
        phr = dlg:AddPhrase("tm_job_nothing", tostring(self.task_info[v].no_phrase_id), tostring(self.task_info[v].desc_phrase_id), -10000)
        phrase_script = phr:GetPhraseScript()
        phrase_script:AddPrecondition("manager_task.precondition_notcompleted_task")
        
        phr = dlg:AddPhrase("tm_job_completed", tostring(self.task_info[v].completed_phrase_id), tostring(self.task_info[v].desc_phrase_id), -10000)
        phrase_script = phr:GetPhraseScript()
        phrase_script:AddPrecondition("manager_task.precondition_completed_task")

        phr = dlg:AddPhrase("tm_job_rewarded", tostring(self.task_info[v].rewarded_phrase_id), tostring(self.task_info[v].completed_phrase_id), -10000)
        phrase_script = phr:GetPhraseScript()
        phrase_script:AddAction("manager_task.action_task_reward")
    end
end
function CRandomTask:register_target(obj)
    if IsStalker(obj) then
        for k,v in pairs(self.task_id_by_type["kill_stalker"]) do    
            if obj.alive and obj:alive() and obj:profile_name() == self.task_info[v].target then
                if self.task_info[v].target_objects == nil then
                    self.task_info[v].target_objects = {}
                end
                m_cleaner.add_exclude(obj)
                table.insert(self.task_info[v].target_objects, obj.id)
            end
        end
    elseif obj:clsid() == clsid.smart_terrain then
        for k,v in pairs(self.task_id_by_type["eliminate_lager"]) do
            if obj:name() == self.task_info[v].target then
                if self.task_info[v].target_objects == nil then
                    self.task_info[v].target_objects = {}
                end
                table.insert(self.task_info[v].target_objects, obj.id)
            end
        end
        for k,v in pairs(self.task_id_by_type["defend_lager"]) do
            if obj:name() == self.task_info[v].target then
                --// Проверка что в кастом дате указано от кого защищать
                local sm_ini = obj:spawn_ini()
                log('defend_object:name = [%s]', obj:name() )
                local defend_target = cfg_get_number(sm_ini, "random_task", "defend_target", nil, true)
                if self.task_info[v].target_objects == nil then
                    self.task_info[v].target_objects = {}
                end
                table.insert(self.task_info[v].target_objects, obj.id)
            end
        end
    else
        for k,v in pairs(self.task_id_by_type["find_item"]) do
            if obj:section_name() == self.task_info[v].target then
                if self.task_info[v].target_objects == nil then
                    self.task_info[v].target_objects = {}
                end
                m_cleaner.add_exclude(obj)
                table.insert(self.task_info[v].target_objects, obj.id)
            end                
        end
        for k,v in pairs(self.task_id_by_type["find_few_items"]) do
            local targets = self.task_info[v].target_items
            for _,vv in ipairs(targets) do
                if obj:section_name() == vv.section then
                    if self.task_info[v].target_objects == nil then
                        self.task_info[v].target_objects = {}
                    end
                    m_cleaner.add_exclude(obj)
                    table.insert(self.task_info[v].target_objects, obj.id)
                end
            end
        end
    end
end
function CRandomTask:unregister_target(obj)
    if IsStalker(obj) then
        for k,v in pairs(self.task_id_by_type["kill_stalker"]) do    
            if self.task_info[v].target_objects ~= nil then
                for kk,vv in pairs(self.task_info[v].target_objects) do
                    if vv == obj.id then
                        m_cleaner.remove_exclude(obj) --// Karlan->Karlan: пока не известно насколько это корректно
                        table.remove(self.task_info[v].target_objects, vv)
                    end
                end            
            end
        end
    elseif obj:clsid() == clsid.smart_terrain then
    else
        for k,v in pairs(self.task_id_by_type["find_item"]) do
            if self.task_info[v].target_objects ~= nil then
                for kk,vv in pairs(self.task_info[v].target_objects) do
                    if vv == obj.id then
                        m_cleaner.remove_exclude(obj)
                        table.remove(self.task_info[v].target_objects, vv)
                    end
                end            
            end
        end
        for k,v in pairs(self.task_id_by_type["find_few_items"]) do
            if self.task_info[v].target_objects ~= nil then
                for kk,vv in pairs(self.task_info[v].target_objects) do
                    if vv == obj.id then
                        m_cleaner.remove_exclude(obj)
                        table.remove(self.task_info[v].target_objects, vv)
                    end
                end            
            end
        end
    end
end
function CRandomTask:stats()
    printf("### TASK STATISTIC ###")
    for k,v in pairs(self.task_info) do
        if is_table(v.init_condition) then
            printf("#[%s] %s : %s", v.status, k, tostring(v.enabled_props))
        end
    end
end
function CRandomTask:get_task_info()
    return self.task_info
end
--//-----------------------------------------------------------------
--// Dialog actions&preconditions
--//-----------------------------------------------------------------
function init_trader_task_dialog(dlg)
    get_random_task():init_task_dialog(dlg, "trader")
end
function init_barman_task_dialog(dlg)
    get_random_task():init_task_dialog(dlg, "barman")
end
function init_ecolog_task_dialog(dlg)
    get_random_task():init_task_dialog(dlg, "ecolog")
end
function init_dolg_task_dialog(dlg)
    get_random_task():init_task_dialog(dlg, "dolg")
end
function init_freedom_task_dialog(dlg)
    get_random_task():init_task_dialog(dlg, "freedom")
end
function init_shustriy_task_dialog(dlg)
    get_random_task():init_task_dialog(dlg, "shustriy")
end
function init_lisiy_task_dialog(dlg)
    get_random_task():init_task_dialog(dlg, "lisiy")
end
function init_hunter_task_dialog(dlg)
    get_random_task():init_task_dialog(dlg, "hunter")
end
function init_drunk_dolg_task_dialog(dlg)
    get_random_task():init_task_dialog(dlg, "drunk_dolg")
end
function init_petrenko_task_dialog(dlg)
    get_random_task():init_task_dialog(dlg, "petrenko")
end
function init_wolf_task_dialog(dlg)
    get_random_task():init_task_dialog(dlg, "wolf")
end
function init_zastava_commander_task_dialog(dlg)
    get_random_task():init_task_dialog(dlg, "zastava_commander")
end
function init_mercenary_task_dialog(dlg)
    get_random_task():init_task_dialog(dlg, "mercenary")
end
--//---------------------------------------------
function init_trader_reward_dialog(dlg)
    get_random_task():init_reward_dialog(dlg, "trader")
end
function init_barman_reward_dialog(dlg)
    get_random_task():init_reward_dialog(dlg, "barman")
end
function init_ecolog_reward_dialog(dlg)
    get_random_task():init_reward_dialog(dlg, "ecolog")
end
function init_dolg_reward_dialog(dlg)
    get_random_task():init_reward_dialog(dlg, "dolg")
end
function init_freedom_reward_dialog(dlg)
    get_random_task():init_reward_dialog(dlg, "freedom")
end
function init_shustriy_reward_dialog(dlg)
    get_random_task():init_reward_dialog(dlg, "shustriy")
end
function init_lisiy_reward_dialog(dlg)
    get_random_task():init_reward_dialog(dlg, "lisiy")
end
function init_hunter_reward_dialog(dlg)
    get_random_task():init_reward_dialog(dlg, "hunter")
end
function init_drunk_dolg_reward_dialog(dlg)
    get_random_task():init_reward_dialog(dlg, "drunk_dolg")
end
function init_petrenko_reward_dialog(dlg)
    get_random_task():init_reward_dialog(dlg, "petrenko")
end
function init_wolf_reward_dialog(dlg)
    get_random_task():init_reward_dialog(dlg, "wolf")
end
function init_zastava_commander_reward_dialog(dlg)
    get_random_task():init_reward_dialog(dlg, "zastava_commander")
end
function init_mercenary_reward_dialog(dlg)
    get_random_task():init_reward_dialog(dlg, "mercenary")
end
--//---------------------------------------------
function has_active_vendor_task(actor, npc)
    return get_random_task():active_parent_task(actor, npc)
end
function precondition_task_avail(actor, npc, p1, p2, p3)
    return get_random_task():task_avail(_,_,_,_, p3)
end
function precondition_active_task(actor, npc, p1, p2, p3)
    return get_random_task():active_task(actor, npc, p1, p2, p3)
end
function precondition_completed_task(actor, npc, p1, p2, p3)
    return get_random_task():completed_task(actor, npc, p1, p2, p3)
end
function precondition_notcompleted_task(actor, npc, p1, p2, p3)
    return not get_random_task():completed_task(actor, npc, p1, p2, p3)
end
function precondition_vendor_can_task(npc, actor, p1, p2, p3)
    return get_random_task():parent_can_task(actor, npc, p1, p2, p3)
end
function precondition_vendor_cannot_task(npc, actor, p1, p2, p3)
    return not get_random_task():parent_can_task(actor, npc, p1, p2, p3)
end
function precondition_have_completed_job(npc, actor, p1, p2, p3)
    return get_random_task():have_completed_job(actor, npc)
end
function precondition_dont_have_completed_job(npc, actor, p1, p2, p3)
    return not get_random_task():have_completed_job(actor, npc)
end
--//---------------------------------------------
function action_task_show(npc, actor)
    get_random_task():action_task_show(npc, actor)
end
function action_show_reward(npc, actor, p1, p2)
    get_random_task():action_show_reward(npc, actor, p1, p2)
end
function action_give_task(actor, npc, p1, p2)
    get_random_task():action_give_task(actor, npc, p1, p2)
end
function action_refuse_task(npc, actor, p1, p2)
    get_random_task():action_refuse_task(npc, actor, p1, p2)
end
function action_task_reward(actor, npc, p1, p2)
    get_random_task():task_reward(actor, npc, p1, p2)
end
function reward_by_task(task)    
    get_random_task():task_reward_storyline(task)
end
--//---------------------------------------------
function task_complete(p1, p2)
    return get_random_task():task_complete(p1, p2)
end
function task_fail(p1, p2)
    return get_random_task():task_fail(p1, p2)
end
function task_callback(p1, p2, state)
    return get_random_task():task_callback(p1, p2, state)
end
--//-----------------------------------------------------------------
--// Callbacks
--//-----------------------------------------------------------------
local function actor_update(e)
    get_random_task():actor_update()
end
--//-----------------------------------------------------------------------------------------------
--// Initialization module
--//-----------------------------------------------------------------------------------------------
local function presets()
    event("actor_update"):register(actor_update, {__period = 2002}) --// Karlan: ставим медленный апдейт, так как вообще не нужен, а еще и жрет дофига
end
--//-------------------------
function init()
    event("presets"):register(presets)
end
--//-----------------------------------------------------------------------------------------------
--// Serialization module
--//-----------------------------------------------------------------------------------------------
function save(p)
    get_random_task():save(p)
end
function load(p)
    get_random_task():load(p)
end
--//-----------------------------------------------------------------------------------------------
--// External functions
--//-----------------------------------------------------------------------------------------------
function get_random_task()
    if random_task == nil then
        random_task = CRandomTask()
    end
    return random_task
end
--//-----------------------------------------------------------------------------------------------